// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gmtl.proto

#ifndef PROTOBUF_gmtl_2eproto__INCLUDED
#define PROTOBUF_gmtl_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace gmtl {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gmtl_2eproto();
void protobuf_AssignDesc_gmtl_2eproto();
void protobuf_ShutdownFile_gmtl_2eproto();

class Color;
class Attacker;
class Container;
class Destructible;
class Healer;
class LightningBolt;
class Confuser;
class Fireball;
class Pickable;
class MonsterAi;
class ConfusedMonsterAi;
class Ai;
class Actor;
class Log;
class Game;
class Game_Map;
class Game_Player;
class Game_Actors;
class Game_Logs;

enum DestructibleType {
  MONSTER = 0,
  PLAYER = 1
};
bool DestructibleType_IsValid(int value);
const DestructibleType DestructibleType_MIN = MONSTER;
const DestructibleType DestructibleType_MAX = PLAYER;
const int DestructibleType_ARRAYSIZE = DestructibleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DestructibleType_descriptor();
inline const ::std::string& DestructibleType_Name(DestructibleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DestructibleType_descriptor(), value);
}
inline bool DestructibleType_Parse(
    const ::std::string& name, DestructibleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DestructibleType>(
    DestructibleType_descriptor(), name, value);
}
enum PickableType {
  HEALER = 0,
  LIGHTNING_BOLT = 1,
  CONFUSER = 2,
  FIREBALL = 3
};
bool PickableType_IsValid(int value);
const PickableType PickableType_MIN = HEALER;
const PickableType PickableType_MAX = FIREBALL;
const int PickableType_ARRAYSIZE = PickableType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PickableType_descriptor();
inline const ::std::string& PickableType_Name(PickableType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PickableType_descriptor(), value);
}
inline bool PickableType_Parse(
    const ::std::string& name, PickableType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PickableType>(
    PickableType_descriptor(), name, value);
}
enum AiType {
  MONSTER_AI = 0,
  CONFUSED_MONSTER_AI = 1,
  PLAYER_AI = 2
};
bool AiType_IsValid(int value);
const AiType AiType_MIN = MONSTER_AI;
const AiType AiType_MAX = PLAYER_AI;
const int AiType_ARRAYSIZE = AiType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AiType_descriptor();
inline const ::std::string& AiType_Name(AiType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AiType_descriptor(), value);
}
inline bool AiType_Parse(
    const ::std::string& name, AiType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AiType>(
    AiType_descriptor(), name, value);
}
// ===================================================================

class Color : public ::google::protobuf::Message {
 public:
  Color();
  virtual ~Color();

  Color(const Color& from);

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Color& default_instance();

  void Swap(Color* other);

  // implements Message ----------------------------------------------

  Color* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float hue = 1;
  inline bool has_hue() const;
  inline void clear_hue();
  static const int kHueFieldNumber = 1;
  inline float hue() const;
  inline void set_hue(float value);

  // required float saturation = 2;
  inline bool has_saturation() const;
  inline void clear_saturation();
  static const int kSaturationFieldNumber = 2;
  inline float saturation() const;
  inline void set_saturation(float value);

  // required float value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline float value() const;
  inline void set_value(float value);

  // @@protoc_insertion_point(class_scope:gmtl.Color)
 private:
  inline void set_has_hue();
  inline void clear_has_hue();
  inline void set_has_saturation();
  inline void clear_has_saturation();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float hue_;
  float saturation_;
  float value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Color* default_instance_;
};
// -------------------------------------------------------------------

class Attacker : public ::google::protobuf::Message {
 public:
  Attacker();
  virtual ~Attacker();

  Attacker(const Attacker& from);

  inline Attacker& operator=(const Attacker& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Attacker& default_instance();

  void Swap(Attacker* other);

  // implements Message ----------------------------------------------

  Attacker* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Attacker& from);
  void MergeFrom(const Attacker& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float power = 1;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 1;
  inline float power() const;
  inline void set_power(float value);

  // @@protoc_insertion_point(class_scope:gmtl.Attacker)
 private:
  inline void set_has_power();
  inline void clear_has_power();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float power_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Attacker* default_instance_;
};
// -------------------------------------------------------------------

class Container : public ::google::protobuf::Message {
 public:
  Container();
  virtual ~Container();

  Container(const Container& from);

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Container& default_instance();

  void Swap(Container* other);

  // implements Message ----------------------------------------------

  Container* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // required int32 inventory_size = 2;
  inline bool has_inventory_size() const;
  inline void clear_inventory_size();
  static const int kInventorySizeFieldNumber = 2;
  inline ::google::protobuf::int32 inventory_size() const;
  inline void set_inventory_size(::google::protobuf::int32 value);

  // repeated .gmtl.Actor actor = 3;
  inline int actor_size() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 3;
  inline const ::gmtl::Actor& actor(int index) const;
  inline ::gmtl::Actor* mutable_actor(int index);
  inline ::gmtl::Actor* add_actor();
  inline const ::google::protobuf::RepeatedPtrField< ::gmtl::Actor >&
      actor() const;
  inline ::google::protobuf::RepeatedPtrField< ::gmtl::Actor >*
      mutable_actor();

  // @@protoc_insertion_point(class_scope:gmtl.Container)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_inventory_size();
  inline void clear_has_inventory_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 inventory_size_;
  ::google::protobuf::RepeatedPtrField< ::gmtl::Actor > actor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Container* default_instance_;
};
// -------------------------------------------------------------------

class Destructible : public ::google::protobuf::Message {
 public:
  Destructible();
  virtual ~Destructible();

  Destructible(const Destructible& from);

  inline Destructible& operator=(const Destructible& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Destructible& default_instance();

  void Swap(Destructible* other);

  // implements Message ----------------------------------------------

  Destructible* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Destructible& from);
  void MergeFrom(const Destructible& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .gmtl.DestructibleType destructible_type = 1;
  inline bool has_destructible_type() const;
  inline void clear_destructible_type();
  static const int kDestructibleTypeFieldNumber = 1;
  inline ::gmtl::DestructibleType destructible_type() const;
  inline void set_destructible_type(::gmtl::DestructibleType value);

  // required float max_hp = 2;
  inline bool has_max_hp() const;
  inline void clear_max_hp();
  static const int kMaxHpFieldNumber = 2;
  inline float max_hp() const;
  inline void set_max_hp(float value);

  // required float hp = 3;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 3;
  inline float hp() const;
  inline void set_hp(float value);

  // required float defense = 4;
  inline bool has_defense() const;
  inline void clear_defense();
  static const int kDefenseFieldNumber = 4;
  inline float defense() const;
  inline void set_defense(float value);

  // required string corpse_name = 5;
  inline bool has_corpse_name() const;
  inline void clear_corpse_name();
  static const int kCorpseNameFieldNumber = 5;
  inline const ::std::string& corpse_name() const;
  inline void set_corpse_name(const ::std::string& value);
  inline void set_corpse_name(const char* value);
  inline void set_corpse_name(const char* value, size_t size);
  inline ::std::string* mutable_corpse_name();
  inline ::std::string* release_corpse_name();
  inline void set_allocated_corpse_name(::std::string* corpse_name);

  // @@protoc_insertion_point(class_scope:gmtl.Destructible)
 private:
  inline void set_has_destructible_type();
  inline void clear_has_destructible_type();
  inline void set_has_max_hp();
  inline void clear_has_max_hp();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_defense();
  inline void clear_has_defense();
  inline void set_has_corpse_name();
  inline void clear_has_corpse_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int destructible_type_;
  float max_hp_;
  float hp_;
  float defense_;
  ::std::string* corpse_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Destructible* default_instance_;
};
// -------------------------------------------------------------------

class Healer : public ::google::protobuf::Message {
 public:
  Healer();
  virtual ~Healer();

  Healer(const Healer& from);

  inline Healer& operator=(const Healer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Healer& default_instance();

  void Swap(Healer* other);

  // implements Message ----------------------------------------------

  Healer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Healer& from);
  void MergeFrom(const Healer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float amount = 1;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 1;
  inline float amount() const;
  inline void set_amount(float value);

  // @@protoc_insertion_point(class_scope:gmtl.Healer)
 private:
  inline void set_has_amount();
  inline void clear_has_amount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float amount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Healer* default_instance_;
};
// -------------------------------------------------------------------

class LightningBolt : public ::google::protobuf::Message {
 public:
  LightningBolt();
  virtual ~LightningBolt();

  LightningBolt(const LightningBolt& from);

  inline LightningBolt& operator=(const LightningBolt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LightningBolt& default_instance();

  void Swap(LightningBolt* other);

  // implements Message ----------------------------------------------

  LightningBolt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LightningBolt& from);
  void MergeFrom(const LightningBolt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float range = 1;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 1;
  inline float range() const;
  inline void set_range(float value);

  // required float damage = 2;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 2;
  inline float damage() const;
  inline void set_damage(float value);

  // @@protoc_insertion_point(class_scope:gmtl.LightningBolt)
 private:
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_damage();
  inline void clear_has_damage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float range_;
  float damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static LightningBolt* default_instance_;
};
// -------------------------------------------------------------------

class Confuser : public ::google::protobuf::Message {
 public:
  Confuser();
  virtual ~Confuser();

  Confuser(const Confuser& from);

  inline Confuser& operator=(const Confuser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Confuser& default_instance();

  void Swap(Confuser* other);

  // implements Message ----------------------------------------------

  Confuser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Confuser& from);
  void MergeFrom(const Confuser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 nb_turns = 1;
  inline bool has_nb_turns() const;
  inline void clear_nb_turns();
  static const int kNbTurnsFieldNumber = 1;
  inline ::google::protobuf::int32 nb_turns() const;
  inline void set_nb_turns(::google::protobuf::int32 value);

  // required float range = 2;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 2;
  inline float range() const;
  inline void set_range(float value);

  // @@protoc_insertion_point(class_scope:gmtl.Confuser)
 private:
  inline void set_has_nb_turns();
  inline void clear_has_nb_turns();
  inline void set_has_range();
  inline void clear_has_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 nb_turns_;
  float range_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Confuser* default_instance_;
};
// -------------------------------------------------------------------

class Fireball : public ::google::protobuf::Message {
 public:
  Fireball();
  virtual ~Fireball();

  Fireball(const Fireball& from);

  inline Fireball& operator=(const Fireball& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Fireball& default_instance();

  void Swap(Fireball* other);

  // implements Message ----------------------------------------------

  Fireball* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Fireball& from);
  void MergeFrom(const Fireball& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float range = 1;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 1;
  inline float range() const;
  inline void set_range(float value);

  // required float damage = 2;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 2;
  inline float damage() const;
  inline void set_damage(float value);

  // @@protoc_insertion_point(class_scope:gmtl.Fireball)
 private:
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_damage();
  inline void clear_has_damage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float range_;
  float damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Fireball* default_instance_;
};
// -------------------------------------------------------------------

class Pickable : public ::google::protobuf::Message {
 public:
  Pickable();
  virtual ~Pickable();

  Pickable(const Pickable& from);

  inline Pickable& operator=(const Pickable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pickable& default_instance();

  void Swap(Pickable* other);

  // implements Message ----------------------------------------------

  Pickable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pickable& from);
  void MergeFrom(const Pickable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .gmtl.PickableType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::gmtl::PickableType type() const;
  inline void set_type(::gmtl::PickableType value);

  // optional .gmtl.Healer healer = 2;
  inline bool has_healer() const;
  inline void clear_healer();
  static const int kHealerFieldNumber = 2;
  inline const ::gmtl::Healer& healer() const;
  inline ::gmtl::Healer* mutable_healer();
  inline ::gmtl::Healer* release_healer();
  inline void set_allocated_healer(::gmtl::Healer* healer);

  // optional .gmtl.LightningBolt lightning_bolt = 3;
  inline bool has_lightning_bolt() const;
  inline void clear_lightning_bolt();
  static const int kLightningBoltFieldNumber = 3;
  inline const ::gmtl::LightningBolt& lightning_bolt() const;
  inline ::gmtl::LightningBolt* mutable_lightning_bolt();
  inline ::gmtl::LightningBolt* release_lightning_bolt();
  inline void set_allocated_lightning_bolt(::gmtl::LightningBolt* lightning_bolt);

  // optional .gmtl.Confuser confuser = 4;
  inline bool has_confuser() const;
  inline void clear_confuser();
  static const int kConfuserFieldNumber = 4;
  inline const ::gmtl::Confuser& confuser() const;
  inline ::gmtl::Confuser* mutable_confuser();
  inline ::gmtl::Confuser* release_confuser();
  inline void set_allocated_confuser(::gmtl::Confuser* confuser);

  // optional .gmtl.Fireball fireball = 5;
  inline bool has_fireball() const;
  inline void clear_fireball();
  static const int kFireballFieldNumber = 5;
  inline const ::gmtl::Fireball& fireball() const;
  inline ::gmtl::Fireball* mutable_fireball();
  inline ::gmtl::Fireball* release_fireball();
  inline void set_allocated_fireball(::gmtl::Fireball* fireball);

  // @@protoc_insertion_point(class_scope:gmtl.Pickable)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_healer();
  inline void clear_has_healer();
  inline void set_has_lightning_bolt();
  inline void clear_has_lightning_bolt();
  inline void set_has_confuser();
  inline void clear_has_confuser();
  inline void set_has_fireball();
  inline void clear_has_fireball();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::gmtl::Healer* healer_;
  ::gmtl::LightningBolt* lightning_bolt_;
  ::gmtl::Confuser* confuser_;
  ::gmtl::Fireball* fireball_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Pickable* default_instance_;
};
// -------------------------------------------------------------------

class MonsterAi : public ::google::protobuf::Message {
 public:
  MonsterAi();
  virtual ~MonsterAi();

  MonsterAi(const MonsterAi& from);

  inline MonsterAi& operator=(const MonsterAi& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MonsterAi& default_instance();

  void Swap(MonsterAi* other);

  // implements Message ----------------------------------------------

  MonsterAi* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MonsterAi& from);
  void MergeFrom(const MonsterAi& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 move_count = 1;
  inline bool has_move_count() const;
  inline void clear_move_count();
  static const int kMoveCountFieldNumber = 1;
  inline ::google::protobuf::int32 move_count() const;
  inline void set_move_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gmtl.MonsterAi)
 private:
  inline void set_has_move_count();
  inline void clear_has_move_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 move_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static MonsterAi* default_instance_;
};
// -------------------------------------------------------------------

class ConfusedMonsterAi : public ::google::protobuf::Message {
 public:
  ConfusedMonsterAi();
  virtual ~ConfusedMonsterAi();

  ConfusedMonsterAi(const ConfusedMonsterAi& from);

  inline ConfusedMonsterAi& operator=(const ConfusedMonsterAi& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfusedMonsterAi& default_instance();

  void Swap(ConfusedMonsterAi* other);

  // implements Message ----------------------------------------------

  ConfusedMonsterAi* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConfusedMonsterAi& from);
  void MergeFrom(const ConfusedMonsterAi& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 nbTurns = 1;
  inline bool has_nbturns() const;
  inline void clear_nbturns();
  static const int kNbTurnsFieldNumber = 1;
  inline ::google::protobuf::int32 nbturns() const;
  inline void set_nbturns(::google::protobuf::int32 value);

  // required .gmtl.Ai old_ai = 2;
  inline bool has_old_ai() const;
  inline void clear_old_ai();
  static const int kOldAiFieldNumber = 2;
  inline const ::gmtl::Ai& old_ai() const;
  inline ::gmtl::Ai* mutable_old_ai();
  inline ::gmtl::Ai* release_old_ai();
  inline void set_allocated_old_ai(::gmtl::Ai* old_ai);

  // @@protoc_insertion_point(class_scope:gmtl.ConfusedMonsterAi)
 private:
  inline void set_has_nbturns();
  inline void clear_has_nbturns();
  inline void set_has_old_ai();
  inline void clear_has_old_ai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::gmtl::Ai* old_ai_;
  ::google::protobuf::int32 nbturns_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static ConfusedMonsterAi* default_instance_;
};
// -------------------------------------------------------------------

class Ai : public ::google::protobuf::Message {
 public:
  Ai();
  virtual ~Ai();

  Ai(const Ai& from);

  inline Ai& operator=(const Ai& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ai& default_instance();

  void Swap(Ai* other);

  // implements Message ----------------------------------------------

  Ai* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ai& from);
  void MergeFrom(const Ai& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .gmtl.AiType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::gmtl::AiType type() const;
  inline void set_type(::gmtl::AiType value);

  // optional .gmtl.MonsterAi monster_ai = 2;
  inline bool has_monster_ai() const;
  inline void clear_monster_ai();
  static const int kMonsterAiFieldNumber = 2;
  inline const ::gmtl::MonsterAi& monster_ai() const;
  inline ::gmtl::MonsterAi* mutable_monster_ai();
  inline ::gmtl::MonsterAi* release_monster_ai();
  inline void set_allocated_monster_ai(::gmtl::MonsterAi* monster_ai);

  // optional .gmtl.ConfusedMonsterAi confused_monster_ai = 3;
  inline bool has_confused_monster_ai() const;
  inline void clear_confused_monster_ai();
  static const int kConfusedMonsterAiFieldNumber = 3;
  inline const ::gmtl::ConfusedMonsterAi& confused_monster_ai() const;
  inline ::gmtl::ConfusedMonsterAi* mutable_confused_monster_ai();
  inline ::gmtl::ConfusedMonsterAi* release_confused_monster_ai();
  inline void set_allocated_confused_monster_ai(::gmtl::ConfusedMonsterAi* confused_monster_ai);

  // @@protoc_insertion_point(class_scope:gmtl.Ai)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_monster_ai();
  inline void clear_has_monster_ai();
  inline void set_has_confused_monster_ai();
  inline void clear_has_confused_monster_ai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::gmtl::MonsterAi* monster_ai_;
  ::gmtl::ConfusedMonsterAi* confused_monster_ai_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Ai* default_instance_;
};
// -------------------------------------------------------------------

class Actor : public ::google::protobuf::Message {
 public:
  Actor();
  virtual ~Actor();

  Actor(const Actor& from);

  inline Actor& operator=(const Actor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Actor& default_instance();

  void Swap(Actor* other);

  // implements Message ----------------------------------------------

  Actor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Actor& from);
  void MergeFrom(const Actor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 ch = 3;
  inline bool has_ch() const;
  inline void clear_ch();
  static const int kChFieldNumber = 3;
  inline ::google::protobuf::int32 ch() const;
  inline void set_ch(::google::protobuf::int32 value);

  // required .gmtl.Color color = 4;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 4;
  inline const ::gmtl::Color& color() const;
  inline ::gmtl::Color* mutable_color();
  inline ::gmtl::Color* release_color();
  inline void set_allocated_color(::gmtl::Color* color);

  // required string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 blocks = 6;
  inline bool has_blocks() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 6;
  inline ::google::protobuf::int32 blocks() const;
  inline void set_blocks(::google::protobuf::int32 value);

  // optional .gmtl.Attacker attacker = 7;
  inline bool has_attacker() const;
  inline void clear_attacker();
  static const int kAttackerFieldNumber = 7;
  inline const ::gmtl::Attacker& attacker() const;
  inline ::gmtl::Attacker* mutable_attacker();
  inline ::gmtl::Attacker* release_attacker();
  inline void set_allocated_attacker(::gmtl::Attacker* attacker);

  // optional .gmtl.Container container = 8;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 8;
  inline const ::gmtl::Container& container() const;
  inline ::gmtl::Container* mutable_container();
  inline ::gmtl::Container* release_container();
  inline void set_allocated_container(::gmtl::Container* container);

  // optional .gmtl.Destructible destructible = 9;
  inline bool has_destructible() const;
  inline void clear_destructible();
  static const int kDestructibleFieldNumber = 9;
  inline const ::gmtl::Destructible& destructible() const;
  inline ::gmtl::Destructible* mutable_destructible();
  inline ::gmtl::Destructible* release_destructible();
  inline void set_allocated_destructible(::gmtl::Destructible* destructible);

  // optional .gmtl.Pickable pickable = 10;
  inline bool has_pickable() const;
  inline void clear_pickable();
  static const int kPickableFieldNumber = 10;
  inline const ::gmtl::Pickable& pickable() const;
  inline ::gmtl::Pickable* mutable_pickable();
  inline ::gmtl::Pickable* release_pickable();
  inline void set_allocated_pickable(::gmtl::Pickable* pickable);

  // @@protoc_insertion_point(class_scope:gmtl.Actor)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_ch();
  inline void clear_has_ch();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_blocks();
  inline void clear_has_blocks();
  inline void set_has_attacker();
  inline void clear_has_attacker();
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_destructible();
  inline void clear_has_destructible();
  inline void set_has_pickable();
  inline void clear_has_pickable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::gmtl::Color* color_;
  ::google::protobuf::int32 ch_;
  ::google::protobuf::int32 blocks_;
  ::std::string* name_;
  ::gmtl::Attacker* attacker_;
  ::gmtl::Container* container_;
  ::gmtl::Destructible* destructible_;
  ::gmtl::Pickable* pickable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Actor* default_instance_;
};
// -------------------------------------------------------------------

class Log : public ::google::protobuf::Message {
 public:
  Log();
  virtual ~Log();

  Log(const Log& from);

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Log& default_instance();

  void Swap(Log* other);

  // implements Message ----------------------------------------------

  Log* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // required .gmtl.Color color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline const ::gmtl::Color& color() const;
  inline ::gmtl::Color* mutable_color();
  inline ::gmtl::Color* release_color();
  inline void set_allocated_color(::gmtl::Color* color);

  // @@protoc_insertion_point(class_scope:gmtl.Log)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_color();
  inline void clear_has_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::gmtl::Color* color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Log* default_instance_;
};
// -------------------------------------------------------------------

class Game_Map : public ::google::protobuf::Message {
 public:
  Game_Map();
  virtual ~Game_Map();

  Game_Map(const Game_Map& from);

  inline Game_Map& operator=(const Game_Map& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Game_Map& default_instance();

  void Swap(Game_Map* other);

  // implements Message ----------------------------------------------

  Game_Map* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Game_Map& from);
  void MergeFrom(const Game_Map& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // required int32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // required int32 seed = 3;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 3;
  inline ::google::protobuf::int32 seed() const;
  inline void set_seed(::google::protobuf::int32 value);

  // repeated int32 explored_tile = 4;
  inline int explored_tile_size() const;
  inline void clear_explored_tile();
  static const int kExploredTileFieldNumber = 4;
  inline ::google::protobuf::int32 explored_tile(int index) const;
  inline void set_explored_tile(int index, ::google::protobuf::int32 value);
  inline void add_explored_tile(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      explored_tile() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_explored_tile();

  // @@protoc_insertion_point(class_scope:gmtl.Game.Map)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_seed();
  inline void clear_has_seed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > explored_tile_;
  ::google::protobuf::int32 seed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Game_Map* default_instance_;
};
// -------------------------------------------------------------------

class Game_Player : public ::google::protobuf::Message {
 public:
  Game_Player();
  virtual ~Game_Player();

  Game_Player(const Game_Player& from);

  inline Game_Player& operator=(const Game_Player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Game_Player& default_instance();

  void Swap(Game_Player* other);

  // implements Message ----------------------------------------------

  Game_Player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Game_Player& from);
  void MergeFrom(const Game_Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .gmtl.Actor actor = 1;
  inline bool has_actor() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 1;
  inline const ::gmtl::Actor& actor() const;
  inline ::gmtl::Actor* mutable_actor();
  inline ::gmtl::Actor* release_actor();
  inline void set_allocated_actor(::gmtl::Actor* actor);

  // @@protoc_insertion_point(class_scope:gmtl.Game.Player)
 private:
  inline void set_has_actor();
  inline void clear_has_actor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::gmtl::Actor* actor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Game_Player* default_instance_;
};
// -------------------------------------------------------------------

class Game_Actors : public ::google::protobuf::Message {
 public:
  Game_Actors();
  virtual ~Game_Actors();

  Game_Actors(const Game_Actors& from);

  inline Game_Actors& operator=(const Game_Actors& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Game_Actors& default_instance();

  void Swap(Game_Actors* other);

  // implements Message ----------------------------------------------

  Game_Actors* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Game_Actors& from);
  void MergeFrom(const Game_Actors& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gmtl.Actor actor = 1;
  inline int actor_size() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 1;
  inline const ::gmtl::Actor& actor(int index) const;
  inline ::gmtl::Actor* mutable_actor(int index);
  inline ::gmtl::Actor* add_actor();
  inline const ::google::protobuf::RepeatedPtrField< ::gmtl::Actor >&
      actor() const;
  inline ::google::protobuf::RepeatedPtrField< ::gmtl::Actor >*
      mutable_actor();

  // @@protoc_insertion_point(class_scope:gmtl.Game.Actors)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::gmtl::Actor > actor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Game_Actors* default_instance_;
};
// -------------------------------------------------------------------

class Game_Logs : public ::google::protobuf::Message {
 public:
  Game_Logs();
  virtual ~Game_Logs();

  Game_Logs(const Game_Logs& from);

  inline Game_Logs& operator=(const Game_Logs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Game_Logs& default_instance();

  void Swap(Game_Logs* other);

  // implements Message ----------------------------------------------

  Game_Logs* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Game_Logs& from);
  void MergeFrom(const Game_Logs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gmtl.Log log = 1;
  inline int log_size() const;
  inline void clear_log();
  static const int kLogFieldNumber = 1;
  inline const ::gmtl::Log& log(int index) const;
  inline ::gmtl::Log* mutable_log(int index);
  inline ::gmtl::Log* add_log();
  inline const ::google::protobuf::RepeatedPtrField< ::gmtl::Log >&
      log() const;
  inline ::google::protobuf::RepeatedPtrField< ::gmtl::Log >*
      mutable_log();

  // @@protoc_insertion_point(class_scope:gmtl.Game.Logs)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::gmtl::Log > log_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Game_Logs* default_instance_;
};
// -------------------------------------------------------------------

class Game : public ::google::protobuf::Message {
 public:
  Game();
  virtual ~Game();

  Game(const Game& from);

  inline Game& operator=(const Game& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Game& default_instance();

  void Swap(Game* other);

  // implements Message ----------------------------------------------

  Game* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Game& from);
  void MergeFrom(const Game& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Game_Map Map;
  typedef Game_Player Player;
  typedef Game_Actors Actors;
  typedef Game_Logs Logs;

  // accessors -------------------------------------------------------

  // required .gmtl.Game.Map map = 1;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 1;
  inline const ::gmtl::Game_Map& map() const;
  inline ::gmtl::Game_Map* mutable_map();
  inline ::gmtl::Game_Map* release_map();
  inline void set_allocated_map(::gmtl::Game_Map* map);

  // optional .gmtl.Game.Player player = 2;
  inline bool has_player() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 2;
  inline const ::gmtl::Game_Player& player() const;
  inline ::gmtl::Game_Player* mutable_player();
  inline ::gmtl::Game_Player* release_player();
  inline void set_allocated_player(::gmtl::Game_Player* player);

  // optional .gmtl.Game.Actors actors = 3;
  inline bool has_actors() const;
  inline void clear_actors();
  static const int kActorsFieldNumber = 3;
  inline const ::gmtl::Game_Actors& actors() const;
  inline ::gmtl::Game_Actors* mutable_actors();
  inline ::gmtl::Game_Actors* release_actors();
  inline void set_allocated_actors(::gmtl::Game_Actors* actors);

  // optional .gmtl.Game.Logs logs = 4;
  inline bool has_logs() const;
  inline void clear_logs();
  static const int kLogsFieldNumber = 4;
  inline const ::gmtl::Game_Logs& logs() const;
  inline ::gmtl::Game_Logs* mutable_logs();
  inline ::gmtl::Game_Logs* release_logs();
  inline void set_allocated_logs(::gmtl::Game_Logs* logs);

  // @@protoc_insertion_point(class_scope:gmtl.Game)
 private:
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_player();
  inline void clear_has_player();
  inline void set_has_actors();
  inline void clear_has_actors();
  inline void set_has_logs();
  inline void clear_has_logs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::gmtl::Game_Map* map_;
  ::gmtl::Game_Player* player_;
  ::gmtl::Game_Actors* actors_;
  ::gmtl::Game_Logs* logs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_gmtl_2eproto();
  friend void protobuf_AssignDesc_gmtl_2eproto();
  friend void protobuf_ShutdownFile_gmtl_2eproto();

  void InitAsDefaultInstance();
  static Game* default_instance_;
};
// ===================================================================


// ===================================================================

// Color

// required float hue = 1;
inline bool Color::has_hue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Color::set_has_hue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Color::clear_has_hue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Color::clear_hue() {
  hue_ = 0;
  clear_has_hue();
}
inline float Color::hue() const {
  return hue_;
}
inline void Color::set_hue(float value) {
  set_has_hue();
  hue_ = value;
}

// required float saturation = 2;
inline bool Color::has_saturation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Color::set_has_saturation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Color::clear_has_saturation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Color::clear_saturation() {
  saturation_ = 0;
  clear_has_saturation();
}
inline float Color::saturation() const {
  return saturation_;
}
inline void Color::set_saturation(float value) {
  set_has_saturation();
  saturation_ = value;
}

// required float value = 3;
inline bool Color::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Color::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Color::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Color::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float Color::value() const {
  return value_;
}
inline void Color::set_value(float value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// Attacker

// required float power = 1;
inline bool Attacker::has_power() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attacker::set_has_power() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attacker::clear_has_power() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attacker::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline float Attacker::power() const {
  return power_;
}
inline void Attacker::set_power(float value) {
  set_has_power();
  power_ = value;
}

// -------------------------------------------------------------------

// Container

// required int32 size = 1;
inline bool Container::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Container::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Container::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Container::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 Container::size() const {
  return size_;
}
inline void Container::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// required int32 inventory_size = 2;
inline bool Container::has_inventory_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Container::set_has_inventory_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Container::clear_has_inventory_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Container::clear_inventory_size() {
  inventory_size_ = 0;
  clear_has_inventory_size();
}
inline ::google::protobuf::int32 Container::inventory_size() const {
  return inventory_size_;
}
inline void Container::set_inventory_size(::google::protobuf::int32 value) {
  set_has_inventory_size();
  inventory_size_ = value;
}

// repeated .gmtl.Actor actor = 3;
inline int Container::actor_size() const {
  return actor_.size();
}
inline void Container::clear_actor() {
  actor_.Clear();
}
inline const ::gmtl::Actor& Container::actor(int index) const {
  return actor_.Get(index);
}
inline ::gmtl::Actor* Container::mutable_actor(int index) {
  return actor_.Mutable(index);
}
inline ::gmtl::Actor* Container::add_actor() {
  return actor_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gmtl::Actor >&
Container::actor() const {
  return actor_;
}
inline ::google::protobuf::RepeatedPtrField< ::gmtl::Actor >*
Container::mutable_actor() {
  return &actor_;
}

// -------------------------------------------------------------------

// Destructible

// required .gmtl.DestructibleType destructible_type = 1;
inline bool Destructible::has_destructible_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Destructible::set_has_destructible_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Destructible::clear_has_destructible_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Destructible::clear_destructible_type() {
  destructible_type_ = 0;
  clear_has_destructible_type();
}
inline ::gmtl::DestructibleType Destructible::destructible_type() const {
  return static_cast< ::gmtl::DestructibleType >(destructible_type_);
}
inline void Destructible::set_destructible_type(::gmtl::DestructibleType value) {
  assert(::gmtl::DestructibleType_IsValid(value));
  set_has_destructible_type();
  destructible_type_ = value;
}

// required float max_hp = 2;
inline bool Destructible::has_max_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Destructible::set_has_max_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Destructible::clear_has_max_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Destructible::clear_max_hp() {
  max_hp_ = 0;
  clear_has_max_hp();
}
inline float Destructible::max_hp() const {
  return max_hp_;
}
inline void Destructible::set_max_hp(float value) {
  set_has_max_hp();
  max_hp_ = value;
}

// required float hp = 3;
inline bool Destructible::has_hp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Destructible::set_has_hp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Destructible::clear_has_hp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Destructible::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline float Destructible::hp() const {
  return hp_;
}
inline void Destructible::set_hp(float value) {
  set_has_hp();
  hp_ = value;
}

// required float defense = 4;
inline bool Destructible::has_defense() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Destructible::set_has_defense() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Destructible::clear_has_defense() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Destructible::clear_defense() {
  defense_ = 0;
  clear_has_defense();
}
inline float Destructible::defense() const {
  return defense_;
}
inline void Destructible::set_defense(float value) {
  set_has_defense();
  defense_ = value;
}

// required string corpse_name = 5;
inline bool Destructible::has_corpse_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Destructible::set_has_corpse_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Destructible::clear_has_corpse_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Destructible::clear_corpse_name() {
  if (corpse_name_ != &::google::protobuf::internal::kEmptyString) {
    corpse_name_->clear();
  }
  clear_has_corpse_name();
}
inline const ::std::string& Destructible::corpse_name() const {
  return *corpse_name_;
}
inline void Destructible::set_corpse_name(const ::std::string& value) {
  set_has_corpse_name();
  if (corpse_name_ == &::google::protobuf::internal::kEmptyString) {
    corpse_name_ = new ::std::string;
  }
  corpse_name_->assign(value);
}
inline void Destructible::set_corpse_name(const char* value) {
  set_has_corpse_name();
  if (corpse_name_ == &::google::protobuf::internal::kEmptyString) {
    corpse_name_ = new ::std::string;
  }
  corpse_name_->assign(value);
}
inline void Destructible::set_corpse_name(const char* value, size_t size) {
  set_has_corpse_name();
  if (corpse_name_ == &::google::protobuf::internal::kEmptyString) {
    corpse_name_ = new ::std::string;
  }
  corpse_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Destructible::mutable_corpse_name() {
  set_has_corpse_name();
  if (corpse_name_ == &::google::protobuf::internal::kEmptyString) {
    corpse_name_ = new ::std::string;
  }
  return corpse_name_;
}
inline ::std::string* Destructible::release_corpse_name() {
  clear_has_corpse_name();
  if (corpse_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = corpse_name_;
    corpse_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Destructible::set_allocated_corpse_name(::std::string* corpse_name) {
  if (corpse_name_ != &::google::protobuf::internal::kEmptyString) {
    delete corpse_name_;
  }
  if (corpse_name) {
    set_has_corpse_name();
    corpse_name_ = corpse_name;
  } else {
    clear_has_corpse_name();
    corpse_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Healer

// required float amount = 1;
inline bool Healer::has_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Healer::set_has_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Healer::clear_has_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Healer::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline float Healer::amount() const {
  return amount_;
}
inline void Healer::set_amount(float value) {
  set_has_amount();
  amount_ = value;
}

// -------------------------------------------------------------------

// LightningBolt

// required float range = 1;
inline bool LightningBolt::has_range() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LightningBolt::set_has_range() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LightningBolt::clear_has_range() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LightningBolt::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline float LightningBolt::range() const {
  return range_;
}
inline void LightningBolt::set_range(float value) {
  set_has_range();
  range_ = value;
}

// required float damage = 2;
inline bool LightningBolt::has_damage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LightningBolt::set_has_damage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LightningBolt::clear_has_damage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LightningBolt::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline float LightningBolt::damage() const {
  return damage_;
}
inline void LightningBolt::set_damage(float value) {
  set_has_damage();
  damage_ = value;
}

// -------------------------------------------------------------------

// Confuser

// required int32 nb_turns = 1;
inline bool Confuser::has_nb_turns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Confuser::set_has_nb_turns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Confuser::clear_has_nb_turns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Confuser::clear_nb_turns() {
  nb_turns_ = 0;
  clear_has_nb_turns();
}
inline ::google::protobuf::int32 Confuser::nb_turns() const {
  return nb_turns_;
}
inline void Confuser::set_nb_turns(::google::protobuf::int32 value) {
  set_has_nb_turns();
  nb_turns_ = value;
}

// required float range = 2;
inline bool Confuser::has_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Confuser::set_has_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Confuser::clear_has_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Confuser::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline float Confuser::range() const {
  return range_;
}
inline void Confuser::set_range(float value) {
  set_has_range();
  range_ = value;
}

// -------------------------------------------------------------------

// Fireball

// required float range = 1;
inline bool Fireball::has_range() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fireball::set_has_range() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Fireball::clear_has_range() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Fireball::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline float Fireball::range() const {
  return range_;
}
inline void Fireball::set_range(float value) {
  set_has_range();
  range_ = value;
}

// required float damage = 2;
inline bool Fireball::has_damage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fireball::set_has_damage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Fireball::clear_has_damage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Fireball::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline float Fireball::damage() const {
  return damage_;
}
inline void Fireball::set_damage(float value) {
  set_has_damage();
  damage_ = value;
}

// -------------------------------------------------------------------

// Pickable

// required .gmtl.PickableType type = 1;
inline bool Pickable::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pickable::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pickable::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pickable::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::gmtl::PickableType Pickable::type() const {
  return static_cast< ::gmtl::PickableType >(type_);
}
inline void Pickable::set_type(::gmtl::PickableType value) {
  assert(::gmtl::PickableType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .gmtl.Healer healer = 2;
inline bool Pickable::has_healer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pickable::set_has_healer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pickable::clear_has_healer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pickable::clear_healer() {
  if (healer_ != NULL) healer_->::gmtl::Healer::Clear();
  clear_has_healer();
}
inline const ::gmtl::Healer& Pickable::healer() const {
  return healer_ != NULL ? *healer_ : *default_instance_->healer_;
}
inline ::gmtl::Healer* Pickable::mutable_healer() {
  set_has_healer();
  if (healer_ == NULL) healer_ = new ::gmtl::Healer;
  return healer_;
}
inline ::gmtl::Healer* Pickable::release_healer() {
  clear_has_healer();
  ::gmtl::Healer* temp = healer_;
  healer_ = NULL;
  return temp;
}
inline void Pickable::set_allocated_healer(::gmtl::Healer* healer) {
  delete healer_;
  healer_ = healer;
  if (healer) {
    set_has_healer();
  } else {
    clear_has_healer();
  }
}

// optional .gmtl.LightningBolt lightning_bolt = 3;
inline bool Pickable::has_lightning_bolt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pickable::set_has_lightning_bolt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pickable::clear_has_lightning_bolt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pickable::clear_lightning_bolt() {
  if (lightning_bolt_ != NULL) lightning_bolt_->::gmtl::LightningBolt::Clear();
  clear_has_lightning_bolt();
}
inline const ::gmtl::LightningBolt& Pickable::lightning_bolt() const {
  return lightning_bolt_ != NULL ? *lightning_bolt_ : *default_instance_->lightning_bolt_;
}
inline ::gmtl::LightningBolt* Pickable::mutable_lightning_bolt() {
  set_has_lightning_bolt();
  if (lightning_bolt_ == NULL) lightning_bolt_ = new ::gmtl::LightningBolt;
  return lightning_bolt_;
}
inline ::gmtl::LightningBolt* Pickable::release_lightning_bolt() {
  clear_has_lightning_bolt();
  ::gmtl::LightningBolt* temp = lightning_bolt_;
  lightning_bolt_ = NULL;
  return temp;
}
inline void Pickable::set_allocated_lightning_bolt(::gmtl::LightningBolt* lightning_bolt) {
  delete lightning_bolt_;
  lightning_bolt_ = lightning_bolt;
  if (lightning_bolt) {
    set_has_lightning_bolt();
  } else {
    clear_has_lightning_bolt();
  }
}

// optional .gmtl.Confuser confuser = 4;
inline bool Pickable::has_confuser() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Pickable::set_has_confuser() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Pickable::clear_has_confuser() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Pickable::clear_confuser() {
  if (confuser_ != NULL) confuser_->::gmtl::Confuser::Clear();
  clear_has_confuser();
}
inline const ::gmtl::Confuser& Pickable::confuser() const {
  return confuser_ != NULL ? *confuser_ : *default_instance_->confuser_;
}
inline ::gmtl::Confuser* Pickable::mutable_confuser() {
  set_has_confuser();
  if (confuser_ == NULL) confuser_ = new ::gmtl::Confuser;
  return confuser_;
}
inline ::gmtl::Confuser* Pickable::release_confuser() {
  clear_has_confuser();
  ::gmtl::Confuser* temp = confuser_;
  confuser_ = NULL;
  return temp;
}
inline void Pickable::set_allocated_confuser(::gmtl::Confuser* confuser) {
  delete confuser_;
  confuser_ = confuser;
  if (confuser) {
    set_has_confuser();
  } else {
    clear_has_confuser();
  }
}

// optional .gmtl.Fireball fireball = 5;
inline bool Pickable::has_fireball() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Pickable::set_has_fireball() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Pickable::clear_has_fireball() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Pickable::clear_fireball() {
  if (fireball_ != NULL) fireball_->::gmtl::Fireball::Clear();
  clear_has_fireball();
}
inline const ::gmtl::Fireball& Pickable::fireball() const {
  return fireball_ != NULL ? *fireball_ : *default_instance_->fireball_;
}
inline ::gmtl::Fireball* Pickable::mutable_fireball() {
  set_has_fireball();
  if (fireball_ == NULL) fireball_ = new ::gmtl::Fireball;
  return fireball_;
}
inline ::gmtl::Fireball* Pickable::release_fireball() {
  clear_has_fireball();
  ::gmtl::Fireball* temp = fireball_;
  fireball_ = NULL;
  return temp;
}
inline void Pickable::set_allocated_fireball(::gmtl::Fireball* fireball) {
  delete fireball_;
  fireball_ = fireball;
  if (fireball) {
    set_has_fireball();
  } else {
    clear_has_fireball();
  }
}

// -------------------------------------------------------------------

// MonsterAi

// required int32 move_count = 1;
inline bool MonsterAi::has_move_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MonsterAi::set_has_move_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MonsterAi::clear_has_move_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MonsterAi::clear_move_count() {
  move_count_ = 0;
  clear_has_move_count();
}
inline ::google::protobuf::int32 MonsterAi::move_count() const {
  return move_count_;
}
inline void MonsterAi::set_move_count(::google::protobuf::int32 value) {
  set_has_move_count();
  move_count_ = value;
}

// -------------------------------------------------------------------

// ConfusedMonsterAi

// required int32 nbTurns = 1;
inline bool ConfusedMonsterAi::has_nbturns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfusedMonsterAi::set_has_nbturns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfusedMonsterAi::clear_has_nbturns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfusedMonsterAi::clear_nbturns() {
  nbturns_ = 0;
  clear_has_nbturns();
}
inline ::google::protobuf::int32 ConfusedMonsterAi::nbturns() const {
  return nbturns_;
}
inline void ConfusedMonsterAi::set_nbturns(::google::protobuf::int32 value) {
  set_has_nbturns();
  nbturns_ = value;
}

// required .gmtl.Ai old_ai = 2;
inline bool ConfusedMonsterAi::has_old_ai() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfusedMonsterAi::set_has_old_ai() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfusedMonsterAi::clear_has_old_ai() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfusedMonsterAi::clear_old_ai() {
  if (old_ai_ != NULL) old_ai_->::gmtl::Ai::Clear();
  clear_has_old_ai();
}
inline const ::gmtl::Ai& ConfusedMonsterAi::old_ai() const {
  return old_ai_ != NULL ? *old_ai_ : *default_instance_->old_ai_;
}
inline ::gmtl::Ai* ConfusedMonsterAi::mutable_old_ai() {
  set_has_old_ai();
  if (old_ai_ == NULL) old_ai_ = new ::gmtl::Ai;
  return old_ai_;
}
inline ::gmtl::Ai* ConfusedMonsterAi::release_old_ai() {
  clear_has_old_ai();
  ::gmtl::Ai* temp = old_ai_;
  old_ai_ = NULL;
  return temp;
}
inline void ConfusedMonsterAi::set_allocated_old_ai(::gmtl::Ai* old_ai) {
  delete old_ai_;
  old_ai_ = old_ai;
  if (old_ai) {
    set_has_old_ai();
  } else {
    clear_has_old_ai();
  }
}

// -------------------------------------------------------------------

// Ai

// required .gmtl.AiType type = 1;
inline bool Ai::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ai::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ai::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ai::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::gmtl::AiType Ai::type() const {
  return static_cast< ::gmtl::AiType >(type_);
}
inline void Ai::set_type(::gmtl::AiType value) {
  assert(::gmtl::AiType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .gmtl.MonsterAi monster_ai = 2;
inline bool Ai::has_monster_ai() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ai::set_has_monster_ai() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ai::clear_has_monster_ai() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ai::clear_monster_ai() {
  if (monster_ai_ != NULL) monster_ai_->::gmtl::MonsterAi::Clear();
  clear_has_monster_ai();
}
inline const ::gmtl::MonsterAi& Ai::monster_ai() const {
  return monster_ai_ != NULL ? *monster_ai_ : *default_instance_->monster_ai_;
}
inline ::gmtl::MonsterAi* Ai::mutable_monster_ai() {
  set_has_monster_ai();
  if (monster_ai_ == NULL) monster_ai_ = new ::gmtl::MonsterAi;
  return monster_ai_;
}
inline ::gmtl::MonsterAi* Ai::release_monster_ai() {
  clear_has_monster_ai();
  ::gmtl::MonsterAi* temp = monster_ai_;
  monster_ai_ = NULL;
  return temp;
}
inline void Ai::set_allocated_monster_ai(::gmtl::MonsterAi* monster_ai) {
  delete monster_ai_;
  monster_ai_ = monster_ai;
  if (monster_ai) {
    set_has_monster_ai();
  } else {
    clear_has_monster_ai();
  }
}

// optional .gmtl.ConfusedMonsterAi confused_monster_ai = 3;
inline bool Ai::has_confused_monster_ai() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ai::set_has_confused_monster_ai() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ai::clear_has_confused_monster_ai() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ai::clear_confused_monster_ai() {
  if (confused_monster_ai_ != NULL) confused_monster_ai_->::gmtl::ConfusedMonsterAi::Clear();
  clear_has_confused_monster_ai();
}
inline const ::gmtl::ConfusedMonsterAi& Ai::confused_monster_ai() const {
  return confused_monster_ai_ != NULL ? *confused_monster_ai_ : *default_instance_->confused_monster_ai_;
}
inline ::gmtl::ConfusedMonsterAi* Ai::mutable_confused_monster_ai() {
  set_has_confused_monster_ai();
  if (confused_monster_ai_ == NULL) confused_monster_ai_ = new ::gmtl::ConfusedMonsterAi;
  return confused_monster_ai_;
}
inline ::gmtl::ConfusedMonsterAi* Ai::release_confused_monster_ai() {
  clear_has_confused_monster_ai();
  ::gmtl::ConfusedMonsterAi* temp = confused_monster_ai_;
  confused_monster_ai_ = NULL;
  return temp;
}
inline void Ai::set_allocated_confused_monster_ai(::gmtl::ConfusedMonsterAi* confused_monster_ai) {
  delete confused_monster_ai_;
  confused_monster_ai_ = confused_monster_ai;
  if (confused_monster_ai) {
    set_has_confused_monster_ai();
  } else {
    clear_has_confused_monster_ai();
  }
}

// -------------------------------------------------------------------

// Actor

// required int32 x = 1;
inline bool Actor::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Actor::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Actor::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Actor::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Actor::x() const {
  return x_;
}
inline void Actor::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool Actor::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Actor::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Actor::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Actor::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Actor::y() const {
  return y_;
}
inline void Actor::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 ch = 3;
inline bool Actor::has_ch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Actor::set_has_ch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Actor::clear_has_ch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Actor::clear_ch() {
  ch_ = 0;
  clear_has_ch();
}
inline ::google::protobuf::int32 Actor::ch() const {
  return ch_;
}
inline void Actor::set_ch(::google::protobuf::int32 value) {
  set_has_ch();
  ch_ = value;
}

// required .gmtl.Color color = 4;
inline bool Actor::has_color() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Actor::set_has_color() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Actor::clear_has_color() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Actor::clear_color() {
  if (color_ != NULL) color_->::gmtl::Color::Clear();
  clear_has_color();
}
inline const ::gmtl::Color& Actor::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::gmtl::Color* Actor::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::gmtl::Color;
  return color_;
}
inline ::gmtl::Color* Actor::release_color() {
  clear_has_color();
  ::gmtl::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline void Actor::set_allocated_color(::gmtl::Color* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// required string name = 5;
inline bool Actor::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Actor::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Actor::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Actor::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Actor::name() const {
  return *name_;
}
inline void Actor::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Actor::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Actor::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Actor::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Actor::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Actor::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 blocks = 6;
inline bool Actor::has_blocks() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Actor::set_has_blocks() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Actor::clear_has_blocks() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Actor::clear_blocks() {
  blocks_ = 0;
  clear_has_blocks();
}
inline ::google::protobuf::int32 Actor::blocks() const {
  return blocks_;
}
inline void Actor::set_blocks(::google::protobuf::int32 value) {
  set_has_blocks();
  blocks_ = value;
}

// optional .gmtl.Attacker attacker = 7;
inline bool Actor::has_attacker() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Actor::set_has_attacker() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Actor::clear_has_attacker() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Actor::clear_attacker() {
  if (attacker_ != NULL) attacker_->::gmtl::Attacker::Clear();
  clear_has_attacker();
}
inline const ::gmtl::Attacker& Actor::attacker() const {
  return attacker_ != NULL ? *attacker_ : *default_instance_->attacker_;
}
inline ::gmtl::Attacker* Actor::mutable_attacker() {
  set_has_attacker();
  if (attacker_ == NULL) attacker_ = new ::gmtl::Attacker;
  return attacker_;
}
inline ::gmtl::Attacker* Actor::release_attacker() {
  clear_has_attacker();
  ::gmtl::Attacker* temp = attacker_;
  attacker_ = NULL;
  return temp;
}
inline void Actor::set_allocated_attacker(::gmtl::Attacker* attacker) {
  delete attacker_;
  attacker_ = attacker;
  if (attacker) {
    set_has_attacker();
  } else {
    clear_has_attacker();
  }
}

// optional .gmtl.Container container = 8;
inline bool Actor::has_container() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Actor::set_has_container() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Actor::clear_has_container() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Actor::clear_container() {
  if (container_ != NULL) container_->::gmtl::Container::Clear();
  clear_has_container();
}
inline const ::gmtl::Container& Actor::container() const {
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
inline ::gmtl::Container* Actor::mutable_container() {
  set_has_container();
  if (container_ == NULL) container_ = new ::gmtl::Container;
  return container_;
}
inline ::gmtl::Container* Actor::release_container() {
  clear_has_container();
  ::gmtl::Container* temp = container_;
  container_ = NULL;
  return temp;
}
inline void Actor::set_allocated_container(::gmtl::Container* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
}

// optional .gmtl.Destructible destructible = 9;
inline bool Actor::has_destructible() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Actor::set_has_destructible() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Actor::clear_has_destructible() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Actor::clear_destructible() {
  if (destructible_ != NULL) destructible_->::gmtl::Destructible::Clear();
  clear_has_destructible();
}
inline const ::gmtl::Destructible& Actor::destructible() const {
  return destructible_ != NULL ? *destructible_ : *default_instance_->destructible_;
}
inline ::gmtl::Destructible* Actor::mutable_destructible() {
  set_has_destructible();
  if (destructible_ == NULL) destructible_ = new ::gmtl::Destructible;
  return destructible_;
}
inline ::gmtl::Destructible* Actor::release_destructible() {
  clear_has_destructible();
  ::gmtl::Destructible* temp = destructible_;
  destructible_ = NULL;
  return temp;
}
inline void Actor::set_allocated_destructible(::gmtl::Destructible* destructible) {
  delete destructible_;
  destructible_ = destructible;
  if (destructible) {
    set_has_destructible();
  } else {
    clear_has_destructible();
  }
}

// optional .gmtl.Pickable pickable = 10;
inline bool Actor::has_pickable() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Actor::set_has_pickable() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Actor::clear_has_pickable() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Actor::clear_pickable() {
  if (pickable_ != NULL) pickable_->::gmtl::Pickable::Clear();
  clear_has_pickable();
}
inline const ::gmtl::Pickable& Actor::pickable() const {
  return pickable_ != NULL ? *pickable_ : *default_instance_->pickable_;
}
inline ::gmtl::Pickable* Actor::mutable_pickable() {
  set_has_pickable();
  if (pickable_ == NULL) pickable_ = new ::gmtl::Pickable;
  return pickable_;
}
inline ::gmtl::Pickable* Actor::release_pickable() {
  clear_has_pickable();
  ::gmtl::Pickable* temp = pickable_;
  pickable_ = NULL;
  return temp;
}
inline void Actor::set_allocated_pickable(::gmtl::Pickable* pickable) {
  delete pickable_;
  pickable_ = pickable;
  if (pickable) {
    set_has_pickable();
  } else {
    clear_has_pickable();
  }
}

// -------------------------------------------------------------------

// Log

// required string text = 1;
inline bool Log::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Log::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Log::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Log::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Log::text() const {
  return *text_;
}
inline void Log::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Log::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Log::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Log::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Log::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Log::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .gmtl.Color color = 2;
inline bool Log::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Log::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Log::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Log::clear_color() {
  if (color_ != NULL) color_->::gmtl::Color::Clear();
  clear_has_color();
}
inline const ::gmtl::Color& Log::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::gmtl::Color* Log::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::gmtl::Color;
  return color_;
}
inline ::gmtl::Color* Log::release_color() {
  clear_has_color();
  ::gmtl::Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline void Log::set_allocated_color(::gmtl::Color* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// -------------------------------------------------------------------

// Game_Map

// required int32 width = 1;
inline bool Game_Map::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Game_Map::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Game_Map::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Game_Map::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Game_Map::width() const {
  return width_;
}
inline void Game_Map::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// required int32 height = 2;
inline bool Game_Map::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Game_Map::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Game_Map::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Game_Map::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Game_Map::height() const {
  return height_;
}
inline void Game_Map::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// required int32 seed = 3;
inline bool Game_Map::has_seed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Game_Map::set_has_seed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Game_Map::clear_has_seed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Game_Map::clear_seed() {
  seed_ = 0;
  clear_has_seed();
}
inline ::google::protobuf::int32 Game_Map::seed() const {
  return seed_;
}
inline void Game_Map::set_seed(::google::protobuf::int32 value) {
  set_has_seed();
  seed_ = value;
}

// repeated int32 explored_tile = 4;
inline int Game_Map::explored_tile_size() const {
  return explored_tile_.size();
}
inline void Game_Map::clear_explored_tile() {
  explored_tile_.Clear();
}
inline ::google::protobuf::int32 Game_Map::explored_tile(int index) const {
  return explored_tile_.Get(index);
}
inline void Game_Map::set_explored_tile(int index, ::google::protobuf::int32 value) {
  explored_tile_.Set(index, value);
}
inline void Game_Map::add_explored_tile(::google::protobuf::int32 value) {
  explored_tile_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Game_Map::explored_tile() const {
  return explored_tile_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Game_Map::mutable_explored_tile() {
  return &explored_tile_;
}

// -------------------------------------------------------------------

// Game_Player

// required .gmtl.Actor actor = 1;
inline bool Game_Player::has_actor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Game_Player::set_has_actor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Game_Player::clear_has_actor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Game_Player::clear_actor() {
  if (actor_ != NULL) actor_->::gmtl::Actor::Clear();
  clear_has_actor();
}
inline const ::gmtl::Actor& Game_Player::actor() const {
  return actor_ != NULL ? *actor_ : *default_instance_->actor_;
}
inline ::gmtl::Actor* Game_Player::mutable_actor() {
  set_has_actor();
  if (actor_ == NULL) actor_ = new ::gmtl::Actor;
  return actor_;
}
inline ::gmtl::Actor* Game_Player::release_actor() {
  clear_has_actor();
  ::gmtl::Actor* temp = actor_;
  actor_ = NULL;
  return temp;
}
inline void Game_Player::set_allocated_actor(::gmtl::Actor* actor) {
  delete actor_;
  actor_ = actor;
  if (actor) {
    set_has_actor();
  } else {
    clear_has_actor();
  }
}

// -------------------------------------------------------------------

// Game_Actors

// repeated .gmtl.Actor actor = 1;
inline int Game_Actors::actor_size() const {
  return actor_.size();
}
inline void Game_Actors::clear_actor() {
  actor_.Clear();
}
inline const ::gmtl::Actor& Game_Actors::actor(int index) const {
  return actor_.Get(index);
}
inline ::gmtl::Actor* Game_Actors::mutable_actor(int index) {
  return actor_.Mutable(index);
}
inline ::gmtl::Actor* Game_Actors::add_actor() {
  return actor_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gmtl::Actor >&
Game_Actors::actor() const {
  return actor_;
}
inline ::google::protobuf::RepeatedPtrField< ::gmtl::Actor >*
Game_Actors::mutable_actor() {
  return &actor_;
}

// -------------------------------------------------------------------

// Game_Logs

// repeated .gmtl.Log log = 1;
inline int Game_Logs::log_size() const {
  return log_.size();
}
inline void Game_Logs::clear_log() {
  log_.Clear();
}
inline const ::gmtl::Log& Game_Logs::log(int index) const {
  return log_.Get(index);
}
inline ::gmtl::Log* Game_Logs::mutable_log(int index) {
  return log_.Mutable(index);
}
inline ::gmtl::Log* Game_Logs::add_log() {
  return log_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gmtl::Log >&
Game_Logs::log() const {
  return log_;
}
inline ::google::protobuf::RepeatedPtrField< ::gmtl::Log >*
Game_Logs::mutable_log() {
  return &log_;
}

// -------------------------------------------------------------------

// Game

// required .gmtl.Game.Map map = 1;
inline bool Game::has_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Game::set_has_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Game::clear_has_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Game::clear_map() {
  if (map_ != NULL) map_->::gmtl::Game_Map::Clear();
  clear_has_map();
}
inline const ::gmtl::Game_Map& Game::map() const {
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::gmtl::Game_Map* Game::mutable_map() {
  set_has_map();
  if (map_ == NULL) map_ = new ::gmtl::Game_Map;
  return map_;
}
inline ::gmtl::Game_Map* Game::release_map() {
  clear_has_map();
  ::gmtl::Game_Map* temp = map_;
  map_ = NULL;
  return temp;
}
inline void Game::set_allocated_map(::gmtl::Game_Map* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
}

// optional .gmtl.Game.Player player = 2;
inline bool Game::has_player() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Game::set_has_player() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Game::clear_has_player() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Game::clear_player() {
  if (player_ != NULL) player_->::gmtl::Game_Player::Clear();
  clear_has_player();
}
inline const ::gmtl::Game_Player& Game::player() const {
  return player_ != NULL ? *player_ : *default_instance_->player_;
}
inline ::gmtl::Game_Player* Game::mutable_player() {
  set_has_player();
  if (player_ == NULL) player_ = new ::gmtl::Game_Player;
  return player_;
}
inline ::gmtl::Game_Player* Game::release_player() {
  clear_has_player();
  ::gmtl::Game_Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline void Game::set_allocated_player(::gmtl::Game_Player* player) {
  delete player_;
  player_ = player;
  if (player) {
    set_has_player();
  } else {
    clear_has_player();
  }
}

// optional .gmtl.Game.Actors actors = 3;
inline bool Game::has_actors() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Game::set_has_actors() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Game::clear_has_actors() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Game::clear_actors() {
  if (actors_ != NULL) actors_->::gmtl::Game_Actors::Clear();
  clear_has_actors();
}
inline const ::gmtl::Game_Actors& Game::actors() const {
  return actors_ != NULL ? *actors_ : *default_instance_->actors_;
}
inline ::gmtl::Game_Actors* Game::mutable_actors() {
  set_has_actors();
  if (actors_ == NULL) actors_ = new ::gmtl::Game_Actors;
  return actors_;
}
inline ::gmtl::Game_Actors* Game::release_actors() {
  clear_has_actors();
  ::gmtl::Game_Actors* temp = actors_;
  actors_ = NULL;
  return temp;
}
inline void Game::set_allocated_actors(::gmtl::Game_Actors* actors) {
  delete actors_;
  actors_ = actors;
  if (actors) {
    set_has_actors();
  } else {
    clear_has_actors();
  }
}

// optional .gmtl.Game.Logs logs = 4;
inline bool Game::has_logs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Game::set_has_logs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Game::clear_has_logs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Game::clear_logs() {
  if (logs_ != NULL) logs_->::gmtl::Game_Logs::Clear();
  clear_has_logs();
}
inline const ::gmtl::Game_Logs& Game::logs() const {
  return logs_ != NULL ? *logs_ : *default_instance_->logs_;
}
inline ::gmtl::Game_Logs* Game::mutable_logs() {
  set_has_logs();
  if (logs_ == NULL) logs_ = new ::gmtl::Game_Logs;
  return logs_;
}
inline ::gmtl::Game_Logs* Game::release_logs() {
  clear_has_logs();
  ::gmtl::Game_Logs* temp = logs_;
  logs_ = NULL;
  return temp;
}
inline void Game::set_allocated_logs(::gmtl::Game_Logs* logs) {
  delete logs_;
  logs_ = logs;
  if (logs) {
    set_has_logs();
  } else {
    clear_has_logs();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gmtl

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gmtl::DestructibleType>() {
  return ::gmtl::DestructibleType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gmtl::PickableType>() {
  return ::gmtl::PickableType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gmtl::AiType>() {
  return ::gmtl::AiType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gmtl_2eproto__INCLUDED

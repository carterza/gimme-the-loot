// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gmtl.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "gmtl.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace gmtl {

namespace {

const ::google::protobuf::Descriptor* Color_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Color_reflection_ = NULL;
const ::google::protobuf::Descriptor* Attacker_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Attacker_reflection_ = NULL;
const ::google::protobuf::Descriptor* Container_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Container_reflection_ = NULL;
const ::google::protobuf::Descriptor* Destructible_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Destructible_reflection_ = NULL;
const ::google::protobuf::Descriptor* Healer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Healer_reflection_ = NULL;
const ::google::protobuf::Descriptor* LightningBolt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LightningBolt_reflection_ = NULL;
const ::google::protobuf::Descriptor* Confuser_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Confuser_reflection_ = NULL;
const ::google::protobuf::Descriptor* Fireball_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Fireball_reflection_ = NULL;
const ::google::protobuf::Descriptor* Pickable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Pickable_reflection_ = NULL;
const ::google::protobuf::Descriptor* MonsterAi_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MonsterAi_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConfusedMonsterAi_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConfusedMonsterAi_reflection_ = NULL;
const ::google::protobuf::Descriptor* Ai_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Ai_reflection_ = NULL;
const ::google::protobuf::Descriptor* Actor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Actor_reflection_ = NULL;
const ::google::protobuf::Descriptor* Log_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Log_reflection_ = NULL;
const ::google::protobuf::Descriptor* Game_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Game_reflection_ = NULL;
const ::google::protobuf::Descriptor* Game_Map_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Game_Map_reflection_ = NULL;
const ::google::protobuf::Descriptor* Game_Player_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Game_Player_reflection_ = NULL;
const ::google::protobuf::Descriptor* Game_Actors_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Game_Actors_reflection_ = NULL;
const ::google::protobuf::Descriptor* Game_Logs_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Game_Logs_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DestructibleType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* PickableType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* AiType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_gmtl_2eproto() {
  protobuf_AddDesc_gmtl_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "gmtl.proto");
  GOOGLE_CHECK(file != NULL);
  Color_descriptor_ = file->message_type(0);
  static const int Color_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, hue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, saturation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, value_),
  };
  Color_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Color_descriptor_,
      Color::default_instance_,
      Color_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Color, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Color));
  Attacker_descriptor_ = file->message_type(1);
  static const int Attacker_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attacker, power_),
  };
  Attacker_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Attacker_descriptor_,
      Attacker::default_instance_,
      Attacker_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attacker, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attacker, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Attacker));
  Container_descriptor_ = file->message_type(2);
  static const int Container_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Container, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Container, inventory_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Container, actor_),
  };
  Container_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Container_descriptor_,
      Container::default_instance_,
      Container_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Container, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Container, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Container));
  Destructible_descriptor_ = file->message_type(3);
  static const int Destructible_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Destructible, destructible_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Destructible, max_hp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Destructible, hp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Destructible, defense_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Destructible, corpse_name_),
  };
  Destructible_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Destructible_descriptor_,
      Destructible::default_instance_,
      Destructible_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Destructible, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Destructible, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Destructible));
  Healer_descriptor_ = file->message_type(4);
  static const int Healer_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Healer, amount_),
  };
  Healer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Healer_descriptor_,
      Healer::default_instance_,
      Healer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Healer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Healer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Healer));
  LightningBolt_descriptor_ = file->message_type(5);
  static const int LightningBolt_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LightningBolt, range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LightningBolt, damage_),
  };
  LightningBolt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LightningBolt_descriptor_,
      LightningBolt::default_instance_,
      LightningBolt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LightningBolt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LightningBolt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LightningBolt));
  Confuser_descriptor_ = file->message_type(6);
  static const int Confuser_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Confuser, nb_turns_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Confuser, range_),
  };
  Confuser_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Confuser_descriptor_,
      Confuser::default_instance_,
      Confuser_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Confuser, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Confuser, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Confuser));
  Fireball_descriptor_ = file->message_type(7);
  static const int Fireball_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fireball, range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fireball, damage_),
  };
  Fireball_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Fireball_descriptor_,
      Fireball::default_instance_,
      Fireball_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fireball, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fireball, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Fireball));
  Pickable_descriptor_ = file->message_type(8);
  static const int Pickable_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pickable, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pickable, healer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pickable, lightning_bolt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pickable, confuser_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pickable, fireball_),
  };
  Pickable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Pickable_descriptor_,
      Pickable::default_instance_,
      Pickable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pickable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pickable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Pickable));
  MonsterAi_descriptor_ = file->message_type(9);
  static const int MonsterAi_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MonsterAi, move_count_),
  };
  MonsterAi_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MonsterAi_descriptor_,
      MonsterAi::default_instance_,
      MonsterAi_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MonsterAi, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MonsterAi, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MonsterAi));
  ConfusedMonsterAi_descriptor_ = file->message_type(10);
  static const int ConfusedMonsterAi_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConfusedMonsterAi, nbturns_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConfusedMonsterAi, old_ai_),
  };
  ConfusedMonsterAi_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ConfusedMonsterAi_descriptor_,
      ConfusedMonsterAi::default_instance_,
      ConfusedMonsterAi_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConfusedMonsterAi, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConfusedMonsterAi, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ConfusedMonsterAi));
  Ai_descriptor_ = file->message_type(11);
  static const int Ai_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ai, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ai, monster_ai_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ai, confused_monster_ai_),
  };
  Ai_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Ai_descriptor_,
      Ai::default_instance_,
      Ai_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ai, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ai, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Ai));
  Actor_descriptor_ = file->message_type(12);
  static const int Actor_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Actor, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Actor, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Actor, ch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Actor, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Actor, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Actor, blocks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Actor, attacker_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Actor, container_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Actor, destructible_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Actor, pickable_),
  };
  Actor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Actor_descriptor_,
      Actor::default_instance_,
      Actor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Actor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Actor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Actor));
  Log_descriptor_ = file->message_type(13);
  static const int Log_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Log, text_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Log, color_),
  };
  Log_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Log_descriptor_,
      Log::default_instance_,
      Log_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Log, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Log, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Log));
  Game_descriptor_ = file->message_type(14);
  static const int Game_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game, map_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game, player_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game, actors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game, logs_),
  };
  Game_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Game_descriptor_,
      Game::default_instance_,
      Game_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Game));
  Game_Map_descriptor_ = Game_descriptor_->nested_type(0);
  static const int Game_Map_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Map, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Map, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Map, seed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Map, explored_tile_),
  };
  Game_Map_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Game_Map_descriptor_,
      Game_Map::default_instance_,
      Game_Map_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Map, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Map, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Game_Map));
  Game_Player_descriptor_ = Game_descriptor_->nested_type(1);
  static const int Game_Player_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Player, actor_),
  };
  Game_Player_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Game_Player_descriptor_,
      Game_Player::default_instance_,
      Game_Player_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Player, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Player, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Game_Player));
  Game_Actors_descriptor_ = Game_descriptor_->nested_type(2);
  static const int Game_Actors_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Actors, actor_),
  };
  Game_Actors_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Game_Actors_descriptor_,
      Game_Actors::default_instance_,
      Game_Actors_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Actors, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Actors, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Game_Actors));
  Game_Logs_descriptor_ = Game_descriptor_->nested_type(3);
  static const int Game_Logs_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Logs, log_),
  };
  Game_Logs_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Game_Logs_descriptor_,
      Game_Logs::default_instance_,
      Game_Logs_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Logs, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Game_Logs, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Game_Logs));
  DestructibleType_descriptor_ = file->enum_type(0);
  PickableType_descriptor_ = file->enum_type(1);
  AiType_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_gmtl_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Color_descriptor_, &Color::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Attacker_descriptor_, &Attacker::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Container_descriptor_, &Container::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Destructible_descriptor_, &Destructible::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Healer_descriptor_, &Healer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LightningBolt_descriptor_, &LightningBolt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Confuser_descriptor_, &Confuser::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Fireball_descriptor_, &Fireball::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Pickable_descriptor_, &Pickable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MonsterAi_descriptor_, &MonsterAi::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ConfusedMonsterAi_descriptor_, &ConfusedMonsterAi::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Ai_descriptor_, &Ai::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Actor_descriptor_, &Actor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Log_descriptor_, &Log::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Game_descriptor_, &Game::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Game_Map_descriptor_, &Game_Map::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Game_Player_descriptor_, &Game_Player::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Game_Actors_descriptor_, &Game_Actors::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Game_Logs_descriptor_, &Game_Logs::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_gmtl_2eproto() {
  delete Color::default_instance_;
  delete Color_reflection_;
  delete Attacker::default_instance_;
  delete Attacker_reflection_;
  delete Container::default_instance_;
  delete Container_reflection_;
  delete Destructible::default_instance_;
  delete Destructible_reflection_;
  delete Healer::default_instance_;
  delete Healer_reflection_;
  delete LightningBolt::default_instance_;
  delete LightningBolt_reflection_;
  delete Confuser::default_instance_;
  delete Confuser_reflection_;
  delete Fireball::default_instance_;
  delete Fireball_reflection_;
  delete Pickable::default_instance_;
  delete Pickable_reflection_;
  delete MonsterAi::default_instance_;
  delete MonsterAi_reflection_;
  delete ConfusedMonsterAi::default_instance_;
  delete ConfusedMonsterAi_reflection_;
  delete Ai::default_instance_;
  delete Ai_reflection_;
  delete Actor::default_instance_;
  delete Actor_reflection_;
  delete Log::default_instance_;
  delete Log_reflection_;
  delete Game::default_instance_;
  delete Game_reflection_;
  delete Game_Map::default_instance_;
  delete Game_Map_reflection_;
  delete Game_Player::default_instance_;
  delete Game_Player_reflection_;
  delete Game_Actors::default_instance_;
  delete Game_Actors_reflection_;
  delete Game_Logs::default_instance_;
  delete Game_Logs_reflection_;
}

void protobuf_AddDesc_gmtl_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\ngmtl.proto\022\004gmtl\"7\n\005Color\022\013\n\003hue\030\001 \002(\002"
    "\022\022\n\nsaturation\030\002 \002(\002\022\r\n\005value\030\003 \002(\002\"\031\n\010A"
    "ttacker\022\r\n\005power\030\001 \002(\002\"M\n\tContainer\022\014\n\004s"
    "ize\030\001 \002(\005\022\026\n\016inventory_size\030\002 \002(\005\022\032\n\005act"
    "or\030\003 \003(\0132\013.gmtl.Actor\"\203\001\n\014Destructible\0221"
    "\n\021destructible_type\030\001 \002(\0162\026.gmtl.Destruc"
    "tibleType\022\016\n\006max_hp\030\002 \002(\002\022\n\n\002hp\030\003 \002(\002\022\017\n"
    "\007defense\030\004 \002(\002\022\023\n\013corpse_name\030\005 \002(\t\"\030\n\006H"
    "ealer\022\016\n\006amount\030\001 \002(\002\".\n\rLightningBolt\022\r"
    "\n\005range\030\001 \002(\002\022\016\n\006damage\030\002 \002(\002\"+\n\010Confuse"
    "r\022\020\n\010nb_turns\030\001 \002(\005\022\r\n\005range\030\002 \002(\002\")\n\010Fi"
    "reball\022\r\n\005range\030\001 \002(\002\022\016\n\006damage\030\002 \002(\002\"\273\001"
    "\n\010Pickable\022 \n\004type\030\001 \002(\0162\022.gmtl.Pickable"
    "Type\022\034\n\006healer\030\002 \001(\0132\014.gmtl.Healer\022+\n\016li"
    "ghtning_bolt\030\003 \001(\0132\023.gmtl.LightningBolt\022"
    " \n\010confuser\030\004 \001(\0132\016.gmtl.Confuser\022 \n\010fir"
    "eball\030\005 \001(\0132\016.gmtl.Fireball\"\037\n\tMonsterAi"
    "\022\022\n\nmove_count\030\001 \002(\005\">\n\021ConfusedMonsterA"
    "i\022\017\n\007nbTurns\030\001 \002(\005\022\030\n\006old_ai\030\002 \002(\0132\010.gmt"
    "l.Ai\"{\n\002Ai\022\032\n\004type\030\001 \002(\0162\014.gmtl.AiType\022#"
    "\n\nmonster_ai\030\002 \001(\0132\017.gmtl.MonsterAi\0224\n\023c"
    "onfused_monster_ai\030\003 \001(\0132\027.gmtl.Confused"
    "MonsterAi\"\365\001\n\005Actor\022\t\n\001x\030\001 \002(\005\022\t\n\001y\030\002 \002("
    "\005\022\n\n\002ch\030\003 \002(\005\022\032\n\005color\030\004 \002(\0132\013.gmtl.Colo"
    "r\022\014\n\004name\030\005 \002(\t\022\016\n\006blocks\030\006 \002(\005\022 \n\010attac"
    "ker\030\007 \001(\0132\016.gmtl.Attacker\022\"\n\tcontainer\030\010"
    " \001(\0132\017.gmtl.Container\022(\n\014destructible\030\t "
    "\001(\0132\022.gmtl.Destructible\022 \n\010pickable\030\n \001("
    "\0132\016.gmtl.Pickable\"/\n\003Log\022\014\n\004text\030\001 \002(\t\022\032"
    "\n\005color\030\002 \002(\0132\013.gmtl.Color\"\277\002\n\004Game\022\033\n\003m"
    "ap\030\001 \002(\0132\016.gmtl.Game.Map\022!\n\006player\030\002 \002(\013"
    "2\021.gmtl.Game.Player\022!\n\006actors\030\003 \002(\0132\021.gm"
    "tl.Game.Actors\022\035\n\004logs\030\004 \002(\0132\017.gmtl.Game"
    ".Logs\032I\n\003Map\022\r\n\005width\030\001 \002(\005\022\016\n\006height\030\002 "
    "\002(\005\022\014\n\004seed\030\003 \002(\005\022\025\n\rexplored_tile\030\004 \003(\005"
    "\032$\n\006Player\022\032\n\005actor\030\001 \002(\0132\013.gmtl.Actor\032$"
    "\n\006Actors\022\032\n\005actor\030\001 \003(\0132\013.gmtl.Actor\032\036\n\004"
    "Logs\022\026\n\003log\030\001 \003(\0132\t.gmtl.Log*+\n\020Destruct"
    "ibleType\022\013\n\007MONSTER\020\000\022\n\n\006PLAYER\020\001*J\n\014Pic"
    "kableType\022\n\n\006HEALER\020\000\022\022\n\016LIGHTNING_BOLT\020"
    "\001\022\014\n\010CONFUSER\020\002\022\014\n\010FIREBALL\020\003*@\n\006AiType\022"
    "\016\n\nMONSTER_AI\020\000\022\027\n\023CONFUSED_MONSTER_AI\020\001"
    "\022\r\n\tPLAYER_AI\020\002", 1695);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "gmtl.proto", &protobuf_RegisterTypes);
  Color::default_instance_ = new Color();
  Attacker::default_instance_ = new Attacker();
  Container::default_instance_ = new Container();
  Destructible::default_instance_ = new Destructible();
  Healer::default_instance_ = new Healer();
  LightningBolt::default_instance_ = new LightningBolt();
  Confuser::default_instance_ = new Confuser();
  Fireball::default_instance_ = new Fireball();
  Pickable::default_instance_ = new Pickable();
  MonsterAi::default_instance_ = new MonsterAi();
  ConfusedMonsterAi::default_instance_ = new ConfusedMonsterAi();
  Ai::default_instance_ = new Ai();
  Actor::default_instance_ = new Actor();
  Log::default_instance_ = new Log();
  Game::default_instance_ = new Game();
  Game_Map::default_instance_ = new Game_Map();
  Game_Player::default_instance_ = new Game_Player();
  Game_Actors::default_instance_ = new Game_Actors();
  Game_Logs::default_instance_ = new Game_Logs();
  Color::default_instance_->InitAsDefaultInstance();
  Attacker::default_instance_->InitAsDefaultInstance();
  Container::default_instance_->InitAsDefaultInstance();
  Destructible::default_instance_->InitAsDefaultInstance();
  Healer::default_instance_->InitAsDefaultInstance();
  LightningBolt::default_instance_->InitAsDefaultInstance();
  Confuser::default_instance_->InitAsDefaultInstance();
  Fireball::default_instance_->InitAsDefaultInstance();
  Pickable::default_instance_->InitAsDefaultInstance();
  MonsterAi::default_instance_->InitAsDefaultInstance();
  ConfusedMonsterAi::default_instance_->InitAsDefaultInstance();
  Ai::default_instance_->InitAsDefaultInstance();
  Actor::default_instance_->InitAsDefaultInstance();
  Log::default_instance_->InitAsDefaultInstance();
  Game::default_instance_->InitAsDefaultInstance();
  Game_Map::default_instance_->InitAsDefaultInstance();
  Game_Player::default_instance_->InitAsDefaultInstance();
  Game_Actors::default_instance_->InitAsDefaultInstance();
  Game_Logs::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_gmtl_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_gmtl_2eproto {
  StaticDescriptorInitializer_gmtl_2eproto() {
    protobuf_AddDesc_gmtl_2eproto();
  }
} static_descriptor_initializer_gmtl_2eproto_;
const ::google::protobuf::EnumDescriptor* DestructibleType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DestructibleType_descriptor_;
}
bool DestructibleType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PickableType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PickableType_descriptor_;
}
bool PickableType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* AiType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AiType_descriptor_;
}
bool AiType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Color::kHueFieldNumber;
const int Color::kSaturationFieldNumber;
const int Color::kValueFieldNumber;
#endif  // !_MSC_VER

Color::Color()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Color::InitAsDefaultInstance() {
}

Color::Color(const Color& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Color::SharedCtor() {
  _cached_size_ = 0;
  hue_ = 0;
  saturation_ = 0;
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Color::~Color() {
  SharedDtor();
}

void Color::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Color::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Color::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Color_descriptor_;
}

const Color& Color::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Color* Color::default_instance_ = NULL;

Color* Color::New() const {
  return new Color;
}

void Color::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    hue_ = 0;
    saturation_ = 0;
    value_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Color::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float hue = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &hue_)));
          set_has_hue();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_saturation;
        break;
      }

      // required float saturation = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_saturation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &saturation_)));
          set_has_saturation();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_value;
        break;
      }

      // required float value = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Color::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float hue = 1;
  if (has_hue()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->hue(), output);
  }

  // required float saturation = 2;
  if (has_saturation()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->saturation(), output);
  }

  // required float value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Color::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float hue = 1;
  if (has_hue()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->hue(), target);
  }

  // required float saturation = 2;
  if (has_saturation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->saturation(), target);
  }

  // required float value = 3;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Color::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float hue = 1;
    if (has_hue()) {
      total_size += 1 + 4;
    }

    // required float saturation = 2;
    if (has_saturation()) {
      total_size += 1 + 4;
    }

    // required float value = 3;
    if (has_value()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Color::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Color* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Color*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Color::MergeFrom(const Color& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hue()) {
      set_hue(from.hue());
    }
    if (from.has_saturation()) {
      set_saturation(from.saturation());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Color::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Color::CopyFrom(const Color& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Color::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Color::Swap(Color* other) {
  if (other != this) {
    std::swap(hue_, other->hue_);
    std::swap(saturation_, other->saturation_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Color::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Color_descriptor_;
  metadata.reflection = Color_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Attacker::kPowerFieldNumber;
#endif  // !_MSC_VER

Attacker::Attacker()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Attacker::InitAsDefaultInstance() {
}

Attacker::Attacker(const Attacker& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Attacker::SharedCtor() {
  _cached_size_ = 0;
  power_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Attacker::~Attacker() {
  SharedDtor();
}

void Attacker::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Attacker::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Attacker::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Attacker_descriptor_;
}

const Attacker& Attacker::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Attacker* Attacker::default_instance_ = NULL;

Attacker* Attacker::New() const {
  return new Attacker;
}

void Attacker::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    power_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Attacker::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float power = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &power_)));
          set_has_power();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Attacker::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float power = 1;
  if (has_power()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->power(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Attacker::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float power = 1;
  if (has_power()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->power(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Attacker::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float power = 1;
    if (has_power()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Attacker::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Attacker* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Attacker*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Attacker::MergeFrom(const Attacker& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_power()) {
      set_power(from.power());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Attacker::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Attacker::CopyFrom(const Attacker& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attacker::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Attacker::Swap(Attacker* other) {
  if (other != this) {
    std::swap(power_, other->power_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Attacker::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Attacker_descriptor_;
  metadata.reflection = Attacker_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Container::kSizeFieldNumber;
const int Container::kInventorySizeFieldNumber;
const int Container::kActorFieldNumber;
#endif  // !_MSC_VER

Container::Container()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Container::InitAsDefaultInstance() {
}

Container::Container(const Container& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Container::SharedCtor() {
  _cached_size_ = 0;
  size_ = 0;
  inventory_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Container::~Container() {
  SharedDtor();
}

void Container::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Container::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Container::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Container_descriptor_;
}

const Container& Container::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Container* Container::default_instance_ = NULL;

Container* Container::New() const {
  return new Container;
}

void Container::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    size_ = 0;
    inventory_size_ = 0;
  }
  actor_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Container::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 size = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_inventory_size;
        break;
      }

      // required int32 inventory_size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_inventory_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &inventory_size_)));
          set_has_inventory_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_actor;
        break;
      }

      // repeated .gmtl.Actor actor = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_actor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_actor()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_actor;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Container::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 size = 1;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->size(), output);
  }

  // required int32 inventory_size = 2;
  if (has_inventory_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->inventory_size(), output);
  }

  // repeated .gmtl.Actor actor = 3;
  for (int i = 0; i < this->actor_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->actor(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Container::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 size = 1;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->size(), target);
  }

  // required int32 inventory_size = 2;
  if (has_inventory_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->inventory_size(), target);
  }

  // repeated .gmtl.Actor actor = 3;
  for (int i = 0; i < this->actor_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->actor(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Container::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 size = 1;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->size());
    }

    // required int32 inventory_size = 2;
    if (has_inventory_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->inventory_size());
    }

  }
  // repeated .gmtl.Actor actor = 3;
  total_size += 1 * this->actor_size();
  for (int i = 0; i < this->actor_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->actor(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Container::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Container* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Container*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Container::MergeFrom(const Container& from) {
  GOOGLE_CHECK_NE(&from, this);
  actor_.MergeFrom(from.actor_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_inventory_size()) {
      set_inventory_size(from.inventory_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Container::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Container::CopyFrom(const Container& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Container::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < actor_size(); i++) {
    if (!this->actor(i).IsInitialized()) return false;
  }
  return true;
}

void Container::Swap(Container* other) {
  if (other != this) {
    std::swap(size_, other->size_);
    std::swap(inventory_size_, other->inventory_size_);
    actor_.Swap(&other->actor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Container::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Container_descriptor_;
  metadata.reflection = Container_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Destructible::kDestructibleTypeFieldNumber;
const int Destructible::kMaxHpFieldNumber;
const int Destructible::kHpFieldNumber;
const int Destructible::kDefenseFieldNumber;
const int Destructible::kCorpseNameFieldNumber;
#endif  // !_MSC_VER

Destructible::Destructible()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Destructible::InitAsDefaultInstance() {
}

Destructible::Destructible(const Destructible& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Destructible::SharedCtor() {
  _cached_size_ = 0;
  destructible_type_ = 0;
  max_hp_ = 0;
  hp_ = 0;
  defense_ = 0;
  corpse_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Destructible::~Destructible() {
  SharedDtor();
}

void Destructible::SharedDtor() {
  if (corpse_name_ != &::google::protobuf::internal::kEmptyString) {
    delete corpse_name_;
  }
  if (this != default_instance_) {
  }
}

void Destructible::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Destructible::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Destructible_descriptor_;
}

const Destructible& Destructible::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Destructible* Destructible::default_instance_ = NULL;

Destructible* Destructible::New() const {
  return new Destructible;
}

void Destructible::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    destructible_type_ = 0;
    max_hp_ = 0;
    hp_ = 0;
    defense_ = 0;
    if (has_corpse_name()) {
      if (corpse_name_ != &::google::protobuf::internal::kEmptyString) {
        corpse_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Destructible::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .gmtl.DestructibleType destructible_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::gmtl::DestructibleType_IsValid(value)) {
            set_destructible_type(static_cast< ::gmtl::DestructibleType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_max_hp;
        break;
      }

      // required float max_hp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_max_hp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_hp_)));
          set_has_max_hp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_hp;
        break;
      }

      // required float hp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_hp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &hp_)));
          set_has_hp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_defense;
        break;
      }

      // required float defense = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_defense:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &defense_)));
          set_has_defense();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_corpse_name;
        break;
      }

      // required string corpse_name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_corpse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_corpse_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->corpse_name().data(), this->corpse_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Destructible::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .gmtl.DestructibleType destructible_type = 1;
  if (has_destructible_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->destructible_type(), output);
  }

  // required float max_hp = 2;
  if (has_max_hp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->max_hp(), output);
  }

  // required float hp = 3;
  if (has_hp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->hp(), output);
  }

  // required float defense = 4;
  if (has_defense()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->defense(), output);
  }

  // required string corpse_name = 5;
  if (has_corpse_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->corpse_name().data(), this->corpse_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->corpse_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Destructible::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .gmtl.DestructibleType destructible_type = 1;
  if (has_destructible_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->destructible_type(), target);
  }

  // required float max_hp = 2;
  if (has_max_hp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->max_hp(), target);
  }

  // required float hp = 3;
  if (has_hp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->hp(), target);
  }

  // required float defense = 4;
  if (has_defense()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->defense(), target);
  }

  // required string corpse_name = 5;
  if (has_corpse_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->corpse_name().data(), this->corpse_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->corpse_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Destructible::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .gmtl.DestructibleType destructible_type = 1;
    if (has_destructible_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->destructible_type());
    }

    // required float max_hp = 2;
    if (has_max_hp()) {
      total_size += 1 + 4;
    }

    // required float hp = 3;
    if (has_hp()) {
      total_size += 1 + 4;
    }

    // required float defense = 4;
    if (has_defense()) {
      total_size += 1 + 4;
    }

    // required string corpse_name = 5;
    if (has_corpse_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->corpse_name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Destructible::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Destructible* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Destructible*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Destructible::MergeFrom(const Destructible& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_destructible_type()) {
      set_destructible_type(from.destructible_type());
    }
    if (from.has_max_hp()) {
      set_max_hp(from.max_hp());
    }
    if (from.has_hp()) {
      set_hp(from.hp());
    }
    if (from.has_defense()) {
      set_defense(from.defense());
    }
    if (from.has_corpse_name()) {
      set_corpse_name(from.corpse_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Destructible::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Destructible::CopyFrom(const Destructible& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Destructible::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void Destructible::Swap(Destructible* other) {
  if (other != this) {
    std::swap(destructible_type_, other->destructible_type_);
    std::swap(max_hp_, other->max_hp_);
    std::swap(hp_, other->hp_);
    std::swap(defense_, other->defense_);
    std::swap(corpse_name_, other->corpse_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Destructible::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Destructible_descriptor_;
  metadata.reflection = Destructible_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Healer::kAmountFieldNumber;
#endif  // !_MSC_VER

Healer::Healer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Healer::InitAsDefaultInstance() {
}

Healer::Healer(const Healer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Healer::SharedCtor() {
  _cached_size_ = 0;
  amount_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Healer::~Healer() {
  SharedDtor();
}

void Healer::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Healer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Healer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Healer_descriptor_;
}

const Healer& Healer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Healer* Healer::default_instance_ = NULL;

Healer* Healer::New() const {
  return new Healer;
}

void Healer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    amount_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Healer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float amount = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Healer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float amount = 1;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->amount(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Healer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float amount = 1;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->amount(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Healer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float amount = 1;
    if (has_amount()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Healer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Healer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Healer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Healer::MergeFrom(const Healer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_amount()) {
      set_amount(from.amount());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Healer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Healer::CopyFrom(const Healer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Healer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Healer::Swap(Healer* other) {
  if (other != this) {
    std::swap(amount_, other->amount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Healer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Healer_descriptor_;
  metadata.reflection = Healer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LightningBolt::kRangeFieldNumber;
const int LightningBolt::kDamageFieldNumber;
#endif  // !_MSC_VER

LightningBolt::LightningBolt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LightningBolt::InitAsDefaultInstance() {
}

LightningBolt::LightningBolt(const LightningBolt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LightningBolt::SharedCtor() {
  _cached_size_ = 0;
  range_ = 0;
  damage_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LightningBolt::~LightningBolt() {
  SharedDtor();
}

void LightningBolt::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LightningBolt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LightningBolt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LightningBolt_descriptor_;
}

const LightningBolt& LightningBolt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

LightningBolt* LightningBolt::default_instance_ = NULL;

LightningBolt* LightningBolt::New() const {
  return new LightningBolt;
}

void LightningBolt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    range_ = 0;
    damage_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LightningBolt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float range = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &range_)));
          set_has_range();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_damage;
        break;
      }

      // required float damage = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_damage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &damage_)));
          set_has_damage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LightningBolt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float range = 1;
  if (has_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->range(), output);
  }

  // required float damage = 2;
  if (has_damage()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->damage(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LightningBolt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float range = 1;
  if (has_range()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->range(), target);
  }

  // required float damage = 2;
  if (has_damage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->damage(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LightningBolt::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float range = 1;
    if (has_range()) {
      total_size += 1 + 4;
    }

    // required float damage = 2;
    if (has_damage()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LightningBolt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LightningBolt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LightningBolt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LightningBolt::MergeFrom(const LightningBolt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_range()) {
      set_range(from.range());
    }
    if (from.has_damage()) {
      set_damage(from.damage());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LightningBolt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LightningBolt::CopyFrom(const LightningBolt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LightningBolt::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void LightningBolt::Swap(LightningBolt* other) {
  if (other != this) {
    std::swap(range_, other->range_);
    std::swap(damage_, other->damage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LightningBolt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LightningBolt_descriptor_;
  metadata.reflection = LightningBolt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Confuser::kNbTurnsFieldNumber;
const int Confuser::kRangeFieldNumber;
#endif  // !_MSC_VER

Confuser::Confuser()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Confuser::InitAsDefaultInstance() {
}

Confuser::Confuser(const Confuser& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Confuser::SharedCtor() {
  _cached_size_ = 0;
  nb_turns_ = 0;
  range_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Confuser::~Confuser() {
  SharedDtor();
}

void Confuser::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Confuser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Confuser::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Confuser_descriptor_;
}

const Confuser& Confuser::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Confuser* Confuser::default_instance_ = NULL;

Confuser* Confuser::New() const {
  return new Confuser;
}

void Confuser::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    nb_turns_ = 0;
    range_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Confuser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 nb_turns = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nb_turns_)));
          set_has_nb_turns();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_range;
        break;
      }

      // required float range = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_range:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &range_)));
          set_has_range();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Confuser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 nb_turns = 1;
  if (has_nb_turns()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->nb_turns(), output);
  }

  // required float range = 2;
  if (has_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->range(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Confuser::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 nb_turns = 1;
  if (has_nb_turns()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->nb_turns(), target);
  }

  // required float range = 2;
  if (has_range()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->range(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Confuser::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 nb_turns = 1;
    if (has_nb_turns()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nb_turns());
    }

    // required float range = 2;
    if (has_range()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Confuser::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Confuser* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Confuser*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Confuser::MergeFrom(const Confuser& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nb_turns()) {
      set_nb_turns(from.nb_turns());
    }
    if (from.has_range()) {
      set_range(from.range());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Confuser::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Confuser::CopyFrom(const Confuser& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Confuser::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Confuser::Swap(Confuser* other) {
  if (other != this) {
    std::swap(nb_turns_, other->nb_turns_);
    std::swap(range_, other->range_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Confuser::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Confuser_descriptor_;
  metadata.reflection = Confuser_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Fireball::kRangeFieldNumber;
const int Fireball::kDamageFieldNumber;
#endif  // !_MSC_VER

Fireball::Fireball()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Fireball::InitAsDefaultInstance() {
}

Fireball::Fireball(const Fireball& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Fireball::SharedCtor() {
  _cached_size_ = 0;
  range_ = 0;
  damage_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Fireball::~Fireball() {
  SharedDtor();
}

void Fireball::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Fireball::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Fireball::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Fireball_descriptor_;
}

const Fireball& Fireball::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Fireball* Fireball::default_instance_ = NULL;

Fireball* Fireball::New() const {
  return new Fireball;
}

void Fireball::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    range_ = 0;
    damage_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Fireball::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float range = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &range_)));
          set_has_range();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_damage;
        break;
      }

      // required float damage = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_damage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &damage_)));
          set_has_damage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Fireball::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float range = 1;
  if (has_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->range(), output);
  }

  // required float damage = 2;
  if (has_damage()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->damage(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Fireball::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float range = 1;
  if (has_range()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->range(), target);
  }

  // required float damage = 2;
  if (has_damage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->damage(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Fireball::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float range = 1;
    if (has_range()) {
      total_size += 1 + 4;
    }

    // required float damage = 2;
    if (has_damage()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Fireball::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Fireball* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Fireball*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Fireball::MergeFrom(const Fireball& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_range()) {
      set_range(from.range());
    }
    if (from.has_damage()) {
      set_damage(from.damage());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Fireball::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Fireball::CopyFrom(const Fireball& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fireball::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Fireball::Swap(Fireball* other) {
  if (other != this) {
    std::swap(range_, other->range_);
    std::swap(damage_, other->damage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Fireball::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Fireball_descriptor_;
  metadata.reflection = Fireball_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Pickable::kTypeFieldNumber;
const int Pickable::kHealerFieldNumber;
const int Pickable::kLightningBoltFieldNumber;
const int Pickable::kConfuserFieldNumber;
const int Pickable::kFireballFieldNumber;
#endif  // !_MSC_VER

Pickable::Pickable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Pickable::InitAsDefaultInstance() {
  healer_ = const_cast< ::gmtl::Healer*>(&::gmtl::Healer::default_instance());
  lightning_bolt_ = const_cast< ::gmtl::LightningBolt*>(&::gmtl::LightningBolt::default_instance());
  confuser_ = const_cast< ::gmtl::Confuser*>(&::gmtl::Confuser::default_instance());
  fireball_ = const_cast< ::gmtl::Fireball*>(&::gmtl::Fireball::default_instance());
}

Pickable::Pickable(const Pickable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Pickable::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  healer_ = NULL;
  lightning_bolt_ = NULL;
  confuser_ = NULL;
  fireball_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Pickable::~Pickable() {
  SharedDtor();
}

void Pickable::SharedDtor() {
  if (this != default_instance_) {
    delete healer_;
    delete lightning_bolt_;
    delete confuser_;
    delete fireball_;
  }
}

void Pickable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Pickable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Pickable_descriptor_;
}

const Pickable& Pickable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Pickable* Pickable::default_instance_ = NULL;

Pickable* Pickable::New() const {
  return new Pickable;
}

void Pickable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_healer()) {
      if (healer_ != NULL) healer_->::gmtl::Healer::Clear();
    }
    if (has_lightning_bolt()) {
      if (lightning_bolt_ != NULL) lightning_bolt_->::gmtl::LightningBolt::Clear();
    }
    if (has_confuser()) {
      if (confuser_ != NULL) confuser_->::gmtl::Confuser::Clear();
    }
    if (has_fireball()) {
      if (fireball_ != NULL) fireball_->::gmtl::Fireball::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Pickable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .gmtl.PickableType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::gmtl::PickableType_IsValid(value)) {
            set_type(static_cast< ::gmtl::PickableType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_healer;
        break;
      }

      // optional .gmtl.Healer healer = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_healer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_healer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_lightning_bolt;
        break;
      }

      // optional .gmtl.LightningBolt lightning_bolt = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lightning_bolt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lightning_bolt()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_confuser;
        break;
      }

      // optional .gmtl.Confuser confuser = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_confuser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_confuser()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_fireball;
        break;
      }

      // optional .gmtl.Fireball fireball = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fireball:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fireball()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Pickable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .gmtl.PickableType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .gmtl.Healer healer = 2;
  if (has_healer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->healer(), output);
  }

  // optional .gmtl.LightningBolt lightning_bolt = 3;
  if (has_lightning_bolt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->lightning_bolt(), output);
  }

  // optional .gmtl.Confuser confuser = 4;
  if (has_confuser()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->confuser(), output);
  }

  // optional .gmtl.Fireball fireball = 5;
  if (has_fireball()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->fireball(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Pickable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .gmtl.PickableType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .gmtl.Healer healer = 2;
  if (has_healer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->healer(), target);
  }

  // optional .gmtl.LightningBolt lightning_bolt = 3;
  if (has_lightning_bolt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->lightning_bolt(), target);
  }

  // optional .gmtl.Confuser confuser = 4;
  if (has_confuser()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->confuser(), target);
  }

  // optional .gmtl.Fireball fireball = 5;
  if (has_fireball()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->fireball(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Pickable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .gmtl.PickableType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .gmtl.Healer healer = 2;
    if (has_healer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->healer());
    }

    // optional .gmtl.LightningBolt lightning_bolt = 3;
    if (has_lightning_bolt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lightning_bolt());
    }

    // optional .gmtl.Confuser confuser = 4;
    if (has_confuser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->confuser());
    }

    // optional .gmtl.Fireball fireball = 5;
    if (has_fireball()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fireball());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pickable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Pickable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Pickable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Pickable::MergeFrom(const Pickable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_healer()) {
      mutable_healer()->::gmtl::Healer::MergeFrom(from.healer());
    }
    if (from.has_lightning_bolt()) {
      mutable_lightning_bolt()->::gmtl::LightningBolt::MergeFrom(from.lightning_bolt());
    }
    if (from.has_confuser()) {
      mutable_confuser()->::gmtl::Confuser::MergeFrom(from.confuser());
    }
    if (from.has_fireball()) {
      mutable_fireball()->::gmtl::Fireball::MergeFrom(from.fireball());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Pickable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pickable::CopyFrom(const Pickable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pickable::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_healer()) {
    if (!this->healer().IsInitialized()) return false;
  }
  if (has_lightning_bolt()) {
    if (!this->lightning_bolt().IsInitialized()) return false;
  }
  if (has_confuser()) {
    if (!this->confuser().IsInitialized()) return false;
  }
  if (has_fireball()) {
    if (!this->fireball().IsInitialized()) return false;
  }
  return true;
}

void Pickable::Swap(Pickable* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(healer_, other->healer_);
    std::swap(lightning_bolt_, other->lightning_bolt_);
    std::swap(confuser_, other->confuser_);
    std::swap(fireball_, other->fireball_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Pickable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Pickable_descriptor_;
  metadata.reflection = Pickable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MonsterAi::kMoveCountFieldNumber;
#endif  // !_MSC_VER

MonsterAi::MonsterAi()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MonsterAi::InitAsDefaultInstance() {
}

MonsterAi::MonsterAi(const MonsterAi& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MonsterAi::SharedCtor() {
  _cached_size_ = 0;
  move_count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MonsterAi::~MonsterAi() {
  SharedDtor();
}

void MonsterAi::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MonsterAi::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MonsterAi::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MonsterAi_descriptor_;
}

const MonsterAi& MonsterAi::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

MonsterAi* MonsterAi::default_instance_ = NULL;

MonsterAi* MonsterAi::New() const {
  return new MonsterAi;
}

void MonsterAi::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    move_count_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MonsterAi::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 move_count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &move_count_)));
          set_has_move_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MonsterAi::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 move_count = 1;
  if (has_move_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->move_count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MonsterAi::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 move_count = 1;
  if (has_move_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->move_count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MonsterAi::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 move_count = 1;
    if (has_move_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->move_count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MonsterAi::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MonsterAi* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MonsterAi*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MonsterAi::MergeFrom(const MonsterAi& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_move_count()) {
      set_move_count(from.move_count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MonsterAi::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MonsterAi::CopyFrom(const MonsterAi& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MonsterAi::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MonsterAi::Swap(MonsterAi* other) {
  if (other != this) {
    std::swap(move_count_, other->move_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MonsterAi::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MonsterAi_descriptor_;
  metadata.reflection = MonsterAi_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ConfusedMonsterAi::kNbTurnsFieldNumber;
const int ConfusedMonsterAi::kOldAiFieldNumber;
#endif  // !_MSC_VER

ConfusedMonsterAi::ConfusedMonsterAi()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ConfusedMonsterAi::InitAsDefaultInstance() {
  old_ai_ = const_cast< ::gmtl::Ai*>(&::gmtl::Ai::default_instance());
}

ConfusedMonsterAi::ConfusedMonsterAi(const ConfusedMonsterAi& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ConfusedMonsterAi::SharedCtor() {
  _cached_size_ = 0;
  nbturns_ = 0;
  old_ai_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConfusedMonsterAi::~ConfusedMonsterAi() {
  SharedDtor();
}

void ConfusedMonsterAi::SharedDtor() {
  if (this != default_instance_) {
    delete old_ai_;
  }
}

void ConfusedMonsterAi::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConfusedMonsterAi::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConfusedMonsterAi_descriptor_;
}

const ConfusedMonsterAi& ConfusedMonsterAi::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

ConfusedMonsterAi* ConfusedMonsterAi::default_instance_ = NULL;

ConfusedMonsterAi* ConfusedMonsterAi::New() const {
  return new ConfusedMonsterAi;
}

void ConfusedMonsterAi::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    nbturns_ = 0;
    if (has_old_ai()) {
      if (old_ai_ != NULL) old_ai_->::gmtl::Ai::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ConfusedMonsterAi::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 nbTurns = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nbturns_)));
          set_has_nbturns();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_old_ai;
        break;
      }

      // required .gmtl.Ai old_ai = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_old_ai:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_old_ai()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ConfusedMonsterAi::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 nbTurns = 1;
  if (has_nbturns()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->nbturns(), output);
  }

  // required .gmtl.Ai old_ai = 2;
  if (has_old_ai()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->old_ai(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ConfusedMonsterAi::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 nbTurns = 1;
  if (has_nbturns()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->nbturns(), target);
  }

  // required .gmtl.Ai old_ai = 2;
  if (has_old_ai()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->old_ai(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ConfusedMonsterAi::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 nbTurns = 1;
    if (has_nbturns()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nbturns());
    }

    // required .gmtl.Ai old_ai = 2;
    if (has_old_ai()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->old_ai());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConfusedMonsterAi::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ConfusedMonsterAi* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ConfusedMonsterAi*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConfusedMonsterAi::MergeFrom(const ConfusedMonsterAi& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nbturns()) {
      set_nbturns(from.nbturns());
    }
    if (from.has_old_ai()) {
      mutable_old_ai()->::gmtl::Ai::MergeFrom(from.old_ai());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ConfusedMonsterAi::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConfusedMonsterAi::CopyFrom(const ConfusedMonsterAi& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfusedMonsterAi::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_old_ai()) {
    if (!this->old_ai().IsInitialized()) return false;
  }
  return true;
}

void ConfusedMonsterAi::Swap(ConfusedMonsterAi* other) {
  if (other != this) {
    std::swap(nbturns_, other->nbturns_);
    std::swap(old_ai_, other->old_ai_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ConfusedMonsterAi::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConfusedMonsterAi_descriptor_;
  metadata.reflection = ConfusedMonsterAi_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Ai::kTypeFieldNumber;
const int Ai::kMonsterAiFieldNumber;
const int Ai::kConfusedMonsterAiFieldNumber;
#endif  // !_MSC_VER

Ai::Ai()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Ai::InitAsDefaultInstance() {
  monster_ai_ = const_cast< ::gmtl::MonsterAi*>(&::gmtl::MonsterAi::default_instance());
  confused_monster_ai_ = const_cast< ::gmtl::ConfusedMonsterAi*>(&::gmtl::ConfusedMonsterAi::default_instance());
}

Ai::Ai(const Ai& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Ai::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  monster_ai_ = NULL;
  confused_monster_ai_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Ai::~Ai() {
  SharedDtor();
}

void Ai::SharedDtor() {
  if (this != default_instance_) {
    delete monster_ai_;
    delete confused_monster_ai_;
  }
}

void Ai::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Ai::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Ai_descriptor_;
}

const Ai& Ai::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Ai* Ai::default_instance_ = NULL;

Ai* Ai::New() const {
  return new Ai;
}

void Ai::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_monster_ai()) {
      if (monster_ai_ != NULL) monster_ai_->::gmtl::MonsterAi::Clear();
    }
    if (has_confused_monster_ai()) {
      if (confused_monster_ai_ != NULL) confused_monster_ai_->::gmtl::ConfusedMonsterAi::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Ai::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .gmtl.AiType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::gmtl::AiType_IsValid(value)) {
            set_type(static_cast< ::gmtl::AiType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_monster_ai;
        break;
      }

      // optional .gmtl.MonsterAi monster_ai = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_monster_ai:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_monster_ai()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_confused_monster_ai;
        break;
      }

      // optional .gmtl.ConfusedMonsterAi confused_monster_ai = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_confused_monster_ai:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_confused_monster_ai()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Ai::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .gmtl.AiType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .gmtl.MonsterAi monster_ai = 2;
  if (has_monster_ai()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->monster_ai(), output);
  }

  // optional .gmtl.ConfusedMonsterAi confused_monster_ai = 3;
  if (has_confused_monster_ai()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->confused_monster_ai(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Ai::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .gmtl.AiType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .gmtl.MonsterAi monster_ai = 2;
  if (has_monster_ai()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->monster_ai(), target);
  }

  // optional .gmtl.ConfusedMonsterAi confused_monster_ai = 3;
  if (has_confused_monster_ai()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->confused_monster_ai(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Ai::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .gmtl.AiType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .gmtl.MonsterAi monster_ai = 2;
    if (has_monster_ai()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->monster_ai());
    }

    // optional .gmtl.ConfusedMonsterAi confused_monster_ai = 3;
    if (has_confused_monster_ai()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->confused_monster_ai());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ai::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Ai* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Ai*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Ai::MergeFrom(const Ai& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_monster_ai()) {
      mutable_monster_ai()->::gmtl::MonsterAi::MergeFrom(from.monster_ai());
    }
    if (from.has_confused_monster_ai()) {
      mutable_confused_monster_ai()->::gmtl::ConfusedMonsterAi::MergeFrom(from.confused_monster_ai());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Ai::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Ai::CopyFrom(const Ai& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ai::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_monster_ai()) {
    if (!this->monster_ai().IsInitialized()) return false;
  }
  if (has_confused_monster_ai()) {
    if (!this->confused_monster_ai().IsInitialized()) return false;
  }
  return true;
}

void Ai::Swap(Ai* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(monster_ai_, other->monster_ai_);
    std::swap(confused_monster_ai_, other->confused_monster_ai_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Ai::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Ai_descriptor_;
  metadata.reflection = Ai_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Actor::kXFieldNumber;
const int Actor::kYFieldNumber;
const int Actor::kChFieldNumber;
const int Actor::kColorFieldNumber;
const int Actor::kNameFieldNumber;
const int Actor::kBlocksFieldNumber;
const int Actor::kAttackerFieldNumber;
const int Actor::kContainerFieldNumber;
const int Actor::kDestructibleFieldNumber;
const int Actor::kPickableFieldNumber;
#endif  // !_MSC_VER

Actor::Actor()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Actor::InitAsDefaultInstance() {
  color_ = const_cast< ::gmtl::Color*>(&::gmtl::Color::default_instance());
  attacker_ = const_cast< ::gmtl::Attacker*>(&::gmtl::Attacker::default_instance());
  container_ = const_cast< ::gmtl::Container*>(&::gmtl::Container::default_instance());
  destructible_ = const_cast< ::gmtl::Destructible*>(&::gmtl::Destructible::default_instance());
  pickable_ = const_cast< ::gmtl::Pickable*>(&::gmtl::Pickable::default_instance());
}

Actor::Actor(const Actor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Actor::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ch_ = 0;
  color_ = NULL;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  blocks_ = 0;
  attacker_ = NULL;
  container_ = NULL;
  destructible_ = NULL;
  pickable_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Actor::~Actor() {
  SharedDtor();
}

void Actor::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete color_;
    delete attacker_;
    delete container_;
    delete destructible_;
    delete pickable_;
  }
}

void Actor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Actor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Actor_descriptor_;
}

const Actor& Actor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Actor* Actor::default_instance_ = NULL;

Actor* Actor::New() const {
  return new Actor;
}

void Actor::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    ch_ = 0;
    if (has_color()) {
      if (color_ != NULL) color_->::gmtl::Color::Clear();
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    blocks_ = 0;
    if (has_attacker()) {
      if (attacker_ != NULL) attacker_->::gmtl::Attacker::Clear();
    }
    if (has_container()) {
      if (container_ != NULL) container_->::gmtl::Container::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_destructible()) {
      if (destructible_ != NULL) destructible_->::gmtl::Destructible::Clear();
    }
    if (has_pickable()) {
      if (pickable_ != NULL) pickable_->::gmtl::Pickable::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Actor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // required int32 y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ch;
        break;
      }

      // required int32 ch = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ch_)));
          set_has_ch();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_color;
        break;
      }

      // required .gmtl.Color color = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_name;
        break;
      }

      // required string name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_blocks;
        break;
      }

      // required int32 blocks = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blocks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &blocks_)));
          set_has_blocks();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_attacker;
        break;
      }

      // optional .gmtl.Attacker attacker = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_attacker:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attacker()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_container;
        break;
      }

      // optional .gmtl.Container container = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_container:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_destructible;
        break;
      }

      // optional .gmtl.Destructible destructible = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_destructible:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_destructible()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_pickable;
        break;
      }

      // optional .gmtl.Pickable pickable = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pickable:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pickable()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Actor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // required int32 y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  // required int32 ch = 3;
  if (has_ch()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->ch(), output);
  }

  // required .gmtl.Color color = 4;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->color(), output);
  }

  // required string name = 5;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->name(), output);
  }

  // required int32 blocks = 6;
  if (has_blocks()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->blocks(), output);
  }

  // optional .gmtl.Attacker attacker = 7;
  if (has_attacker()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->attacker(), output);
  }

  // optional .gmtl.Container container = 8;
  if (has_container()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->container(), output);
  }

  // optional .gmtl.Destructible destructible = 9;
  if (has_destructible()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->destructible(), output);
  }

  // optional .gmtl.Pickable pickable = 10;
  if (has_pickable()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->pickable(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Actor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->x(), target);
  }

  // required int32 y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->y(), target);
  }

  // required int32 ch = 3;
  if (has_ch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->ch(), target);
  }

  // required .gmtl.Color color = 4;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->color(), target);
  }

  // required string name = 5;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->name(), target);
  }

  // required int32 blocks = 6;
  if (has_blocks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->blocks(), target);
  }

  // optional .gmtl.Attacker attacker = 7;
  if (has_attacker()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->attacker(), target);
  }

  // optional .gmtl.Container container = 8;
  if (has_container()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->container(), target);
  }

  // optional .gmtl.Destructible destructible = 9;
  if (has_destructible()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->destructible(), target);
  }

  // optional .gmtl.Pickable pickable = 10;
  if (has_pickable()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->pickable(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Actor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // required int32 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

    // required int32 ch = 3;
    if (has_ch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ch());
    }

    // required .gmtl.Color color = 4;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->color());
    }

    // required string name = 5;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required int32 blocks = 6;
    if (has_blocks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->blocks());
    }

    // optional .gmtl.Attacker attacker = 7;
    if (has_attacker()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attacker());
    }

    // optional .gmtl.Container container = 8;
    if (has_container()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->container());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .gmtl.Destructible destructible = 9;
    if (has_destructible()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->destructible());
    }

    // optional .gmtl.Pickable pickable = 10;
    if (has_pickable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pickable());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Actor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Actor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Actor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Actor::MergeFrom(const Actor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_ch()) {
      set_ch(from.ch());
    }
    if (from.has_color()) {
      mutable_color()->::gmtl::Color::MergeFrom(from.color());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_blocks()) {
      set_blocks(from.blocks());
    }
    if (from.has_attacker()) {
      mutable_attacker()->::gmtl::Attacker::MergeFrom(from.attacker());
    }
    if (from.has_container()) {
      mutable_container()->::gmtl::Container::MergeFrom(from.container());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_destructible()) {
      mutable_destructible()->::gmtl::Destructible::MergeFrom(from.destructible());
    }
    if (from.has_pickable()) {
      mutable_pickable()->::gmtl::Pickable::MergeFrom(from.pickable());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Actor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Actor::CopyFrom(const Actor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Actor::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  if (has_color()) {
    if (!this->color().IsInitialized()) return false;
  }
  if (has_attacker()) {
    if (!this->attacker().IsInitialized()) return false;
  }
  if (has_container()) {
    if (!this->container().IsInitialized()) return false;
  }
  if (has_destructible()) {
    if (!this->destructible().IsInitialized()) return false;
  }
  if (has_pickable()) {
    if (!this->pickable().IsInitialized()) return false;
  }
  return true;
}

void Actor::Swap(Actor* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(ch_, other->ch_);
    std::swap(color_, other->color_);
    std::swap(name_, other->name_);
    std::swap(blocks_, other->blocks_);
    std::swap(attacker_, other->attacker_);
    std::swap(container_, other->container_);
    std::swap(destructible_, other->destructible_);
    std::swap(pickable_, other->pickable_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Actor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Actor_descriptor_;
  metadata.reflection = Actor_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Log::kTextFieldNumber;
const int Log::kColorFieldNumber;
#endif  // !_MSC_VER

Log::Log()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Log::InitAsDefaultInstance() {
  color_ = const_cast< ::gmtl::Color*>(&::gmtl::Color::default_instance());
}

Log::Log(const Log& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Log::SharedCtor() {
  _cached_size_ = 0;
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  color_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Log::~Log() {
  SharedDtor();
}

void Log::SharedDtor() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (this != default_instance_) {
    delete color_;
  }
}

void Log::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Log::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Log_descriptor_;
}

const Log& Log::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Log* Log::default_instance_ = NULL;

Log* Log::New() const {
  return new Log;
}

void Log::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
    if (has_color()) {
      if (color_ != NULL) color_->::gmtl::Color::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Log::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string text = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_color;
        break;
      }

      // required .gmtl.Color color = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Log::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string text = 1;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->text(), output);
  }

  // required .gmtl.Color color = 2;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->color(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Log::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string text = 1;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->text(), target);
  }

  // required .gmtl.Color color = 2;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->color(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Log::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string text = 1;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }

    // required .gmtl.Color color = 2;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->color());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Log::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Log* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Log*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Log::MergeFrom(const Log& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_text()) {
      set_text(from.text());
    }
    if (from.has_color()) {
      mutable_color()->::gmtl::Color::MergeFrom(from.color());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Log::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Log::CopyFrom(const Log& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Log::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_color()) {
    if (!this->color().IsInitialized()) return false;
  }
  return true;
}

void Log::Swap(Log* other) {
  if (other != this) {
    std::swap(text_, other->text_);
    std::swap(color_, other->color_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Log::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Log_descriptor_;
  metadata.reflection = Log_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Game_Map::kWidthFieldNumber;
const int Game_Map::kHeightFieldNumber;
const int Game_Map::kSeedFieldNumber;
const int Game_Map::kExploredTileFieldNumber;
#endif  // !_MSC_VER

Game_Map::Game_Map()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Game_Map::InitAsDefaultInstance() {
}

Game_Map::Game_Map(const Game_Map& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Game_Map::SharedCtor() {
  _cached_size_ = 0;
  width_ = 0;
  height_ = 0;
  seed_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Game_Map::~Game_Map() {
  SharedDtor();
}

void Game_Map::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Game_Map::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Game_Map::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Game_Map_descriptor_;
}

const Game_Map& Game_Map::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Game_Map* Game_Map::default_instance_ = NULL;

Game_Map* Game_Map::New() const {
  return new Game_Map;
}

void Game_Map::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    width_ = 0;
    height_ = 0;
    seed_ = 0;
  }
  explored_tile_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Game_Map::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 width = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_height;
        break;
      }

      // required int32 height = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_seed;
        break;
      }

      // required int32 seed = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seed_)));
          set_has_seed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_explored_tile;
        break;
      }

      // repeated int32 explored_tile = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_explored_tile:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 32, input, this->mutable_explored_tile())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_explored_tile())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_explored_tile;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Game_Map::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 width = 1;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->width(), output);
  }

  // required int32 height = 2;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->height(), output);
  }

  // required int32 seed = 3;
  if (has_seed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->seed(), output);
  }

  // repeated int32 explored_tile = 4;
  for (int i = 0; i < this->explored_tile_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      4, this->explored_tile(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Game_Map::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 width = 1;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->width(), target);
  }

  // required int32 height = 2;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->height(), target);
  }

  // required int32 seed = 3;
  if (has_seed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->seed(), target);
  }

  // repeated int32 explored_tile = 4;
  for (int i = 0; i < this->explored_tile_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(4, this->explored_tile(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Game_Map::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 width = 1;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }

    // required int32 height = 2;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }

    // required int32 seed = 3;
    if (has_seed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seed());
    }

  }
  // repeated int32 explored_tile = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->explored_tile_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->explored_tile(i));
    }
    total_size += 1 * this->explored_tile_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Game_Map::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Game_Map* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Game_Map*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Game_Map::MergeFrom(const Game_Map& from) {
  GOOGLE_CHECK_NE(&from, this);
  explored_tile_.MergeFrom(from.explored_tile_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_seed()) {
      set_seed(from.seed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Game_Map::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Game_Map::CopyFrom(const Game_Map& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_Map::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Game_Map::Swap(Game_Map* other) {
  if (other != this) {
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(seed_, other->seed_);
    explored_tile_.Swap(&other->explored_tile_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Game_Map::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Game_Map_descriptor_;
  metadata.reflection = Game_Map_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Game_Player::kActorFieldNumber;
#endif  // !_MSC_VER

Game_Player::Game_Player()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Game_Player::InitAsDefaultInstance() {
  actor_ = const_cast< ::gmtl::Actor*>(&::gmtl::Actor::default_instance());
}

Game_Player::Game_Player(const Game_Player& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Game_Player::SharedCtor() {
  _cached_size_ = 0;
  actor_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Game_Player::~Game_Player() {
  SharedDtor();
}

void Game_Player::SharedDtor() {
  if (this != default_instance_) {
    delete actor_;
  }
}

void Game_Player::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Game_Player::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Game_Player_descriptor_;
}

const Game_Player& Game_Player::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Game_Player* Game_Player::default_instance_ = NULL;

Game_Player* Game_Player::New() const {
  return new Game_Player;
}

void Game_Player::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_actor()) {
      if (actor_ != NULL) actor_->::gmtl::Actor::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Game_Player::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .gmtl.Actor actor = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_actor()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Game_Player::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .gmtl.Actor actor = 1;
  if (has_actor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->actor(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Game_Player::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .gmtl.Actor actor = 1;
  if (has_actor()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->actor(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Game_Player::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .gmtl.Actor actor = 1;
    if (has_actor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->actor());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Game_Player::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Game_Player* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Game_Player*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Game_Player::MergeFrom(const Game_Player& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_actor()) {
      mutable_actor()->::gmtl::Actor::MergeFrom(from.actor());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Game_Player::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Game_Player::CopyFrom(const Game_Player& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_Player::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_actor()) {
    if (!this->actor().IsInitialized()) return false;
  }
  return true;
}

void Game_Player::Swap(Game_Player* other) {
  if (other != this) {
    std::swap(actor_, other->actor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Game_Player::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Game_Player_descriptor_;
  metadata.reflection = Game_Player_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Game_Actors::kActorFieldNumber;
#endif  // !_MSC_VER

Game_Actors::Game_Actors()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Game_Actors::InitAsDefaultInstance() {
}

Game_Actors::Game_Actors(const Game_Actors& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Game_Actors::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Game_Actors::~Game_Actors() {
  SharedDtor();
}

void Game_Actors::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Game_Actors::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Game_Actors::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Game_Actors_descriptor_;
}

const Game_Actors& Game_Actors::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Game_Actors* Game_Actors::default_instance_ = NULL;

Game_Actors* Game_Actors::New() const {
  return new Game_Actors;
}

void Game_Actors::Clear() {
  actor_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Game_Actors::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .gmtl.Actor actor = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_actor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_actor()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_actor;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Game_Actors::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .gmtl.Actor actor = 1;
  for (int i = 0; i < this->actor_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->actor(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Game_Actors::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .gmtl.Actor actor = 1;
  for (int i = 0; i < this->actor_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->actor(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Game_Actors::ByteSize() const {
  int total_size = 0;

  // repeated .gmtl.Actor actor = 1;
  total_size += 1 * this->actor_size();
  for (int i = 0; i < this->actor_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->actor(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Game_Actors::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Game_Actors* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Game_Actors*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Game_Actors::MergeFrom(const Game_Actors& from) {
  GOOGLE_CHECK_NE(&from, this);
  actor_.MergeFrom(from.actor_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Game_Actors::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Game_Actors::CopyFrom(const Game_Actors& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_Actors::IsInitialized() const {

  for (int i = 0; i < actor_size(); i++) {
    if (!this->actor(i).IsInitialized()) return false;
  }
  return true;
}

void Game_Actors::Swap(Game_Actors* other) {
  if (other != this) {
    actor_.Swap(&other->actor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Game_Actors::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Game_Actors_descriptor_;
  metadata.reflection = Game_Actors_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Game_Logs::kLogFieldNumber;
#endif  // !_MSC_VER

Game_Logs::Game_Logs()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Game_Logs::InitAsDefaultInstance() {
}

Game_Logs::Game_Logs(const Game_Logs& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Game_Logs::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Game_Logs::~Game_Logs() {
  SharedDtor();
}

void Game_Logs::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Game_Logs::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Game_Logs::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Game_Logs_descriptor_;
}

const Game_Logs& Game_Logs::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Game_Logs* Game_Logs::default_instance_ = NULL;

Game_Logs* Game_Logs::New() const {
  return new Game_Logs;
}

void Game_Logs::Clear() {
  log_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Game_Logs::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .gmtl.Log log = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_log:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_log()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_log;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Game_Logs::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .gmtl.Log log = 1;
  for (int i = 0; i < this->log_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->log(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Game_Logs::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .gmtl.Log log = 1;
  for (int i = 0; i < this->log_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->log(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Game_Logs::ByteSize() const {
  int total_size = 0;

  // repeated .gmtl.Log log = 1;
  total_size += 1 * this->log_size();
  for (int i = 0; i < this->log_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->log(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Game_Logs::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Game_Logs* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Game_Logs*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Game_Logs::MergeFrom(const Game_Logs& from) {
  GOOGLE_CHECK_NE(&from, this);
  log_.MergeFrom(from.log_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Game_Logs::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Game_Logs::CopyFrom(const Game_Logs& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game_Logs::IsInitialized() const {

  for (int i = 0; i < log_size(); i++) {
    if (!this->log(i).IsInitialized()) return false;
  }
  return true;
}

void Game_Logs::Swap(Game_Logs* other) {
  if (other != this) {
    log_.Swap(&other->log_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Game_Logs::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Game_Logs_descriptor_;
  metadata.reflection = Game_Logs_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Game::kMapFieldNumber;
const int Game::kPlayerFieldNumber;
const int Game::kActorsFieldNumber;
const int Game::kLogsFieldNumber;
#endif  // !_MSC_VER

Game::Game()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Game::InitAsDefaultInstance() {
  map_ = const_cast< ::gmtl::Game_Map*>(&::gmtl::Game_Map::default_instance());
  player_ = const_cast< ::gmtl::Game_Player*>(&::gmtl::Game_Player::default_instance());
  actors_ = const_cast< ::gmtl::Game_Actors*>(&::gmtl::Game_Actors::default_instance());
  logs_ = const_cast< ::gmtl::Game_Logs*>(&::gmtl::Game_Logs::default_instance());
}

Game::Game(const Game& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Game::SharedCtor() {
  _cached_size_ = 0;
  map_ = NULL;
  player_ = NULL;
  actors_ = NULL;
  logs_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Game::~Game() {
  SharedDtor();
}

void Game::SharedDtor() {
  if (this != default_instance_) {
    delete map_;
    delete player_;
    delete actors_;
    delete logs_;
  }
}

void Game::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Game::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Game_descriptor_;
}

const Game& Game::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gmtl_2eproto();
  return *default_instance_;
}

Game* Game::default_instance_ = NULL;

Game* Game::New() const {
  return new Game;
}

void Game::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_map()) {
      if (map_ != NULL) map_->::gmtl::Game_Map::Clear();
    }
    if (has_player()) {
      if (player_ != NULL) player_->::gmtl::Game_Player::Clear();
    }
    if (has_actors()) {
      if (actors_ != NULL) actors_->::gmtl::Game_Actors::Clear();
    }
    if (has_logs()) {
      if (logs_ != NULL) logs_->::gmtl::Game_Logs::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Game::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .gmtl.Game.Map map = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_map()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_player;
        break;
      }

      // required .gmtl.Game.Player player = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_player:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_player()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_actors;
        break;
      }

      // required .gmtl.Game.Actors actors = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_actors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_actors()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_logs;
        break;
      }

      // required .gmtl.Game.Logs logs = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_logs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_logs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Game::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .gmtl.Game.Map map = 1;
  if (has_map()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->map(), output);
  }

  // required .gmtl.Game.Player player = 2;
  if (has_player()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->player(), output);
  }

  // required .gmtl.Game.Actors actors = 3;
  if (has_actors()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->actors(), output);
  }

  // required .gmtl.Game.Logs logs = 4;
  if (has_logs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->logs(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Game::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .gmtl.Game.Map map = 1;
  if (has_map()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->map(), target);
  }

  // required .gmtl.Game.Player player = 2;
  if (has_player()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->player(), target);
  }

  // required .gmtl.Game.Actors actors = 3;
  if (has_actors()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->actors(), target);
  }

  // required .gmtl.Game.Logs logs = 4;
  if (has_logs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->logs(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Game::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .gmtl.Game.Map map = 1;
    if (has_map()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->map());
    }

    // required .gmtl.Game.Player player = 2;
    if (has_player()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->player());
    }

    // required .gmtl.Game.Actors actors = 3;
    if (has_actors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->actors());
    }

    // required .gmtl.Game.Logs logs = 4;
    if (has_logs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->logs());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Game::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Game* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Game*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Game::MergeFrom(const Game& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map()) {
      mutable_map()->::gmtl::Game_Map::MergeFrom(from.map());
    }
    if (from.has_player()) {
      mutable_player()->::gmtl::Game_Player::MergeFrom(from.player());
    }
    if (from.has_actors()) {
      mutable_actors()->::gmtl::Game_Actors::MergeFrom(from.actors());
    }
    if (from.has_logs()) {
      mutable_logs()->::gmtl::Game_Logs::MergeFrom(from.logs());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Game::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Game::CopyFrom(const Game& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Game::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_map()) {
    if (!this->map().IsInitialized()) return false;
  }
  if (has_player()) {
    if (!this->player().IsInitialized()) return false;
  }
  if (has_actors()) {
    if (!this->actors().IsInitialized()) return false;
  }
  if (has_logs()) {
    if (!this->logs().IsInitialized()) return false;
  }
  return true;
}

void Game::Swap(Game* other) {
  if (other != this) {
    std::swap(map_, other->map_);
    std::swap(player_, other->player_);
    std::swap(actors_, other->actors_);
    std::swap(logs_, other->logs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Game::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Game_descriptor_;
  metadata.reflection = Game_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace gmtl

// @@protoc_insertion_point(global_scope)
